var documenterSearchIndex = {"docs":
[{"location":"quickStart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"If you're already familiar with the concept of flipgraphs, triangulations on closed surfaces and Δ-complexes, and don't to read the whole documentation of what what is, then here are some quick examples of what you can do with this package.","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"In any other case, please be sure to have a look at the rest of the documentation first.","category":"page"},{"location":"quickStart/#Triangulated-Convex-Polygon","page":"Quick Start","title":"Triangulated Convex Polygon","text":"","category":"section"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Create a triangulated convex 10-gon:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> g = triangulated_polygon(10)\nTriangulatedPolygon with 10 vertices, and adjacency list:\n[[2, 10], [1, 3, 10], [2, 4, 10, 9], [3, 5, 9, 8], [4, 6, 8, 7], [5, 7], [6, 8, 5], [7, 9, 4, 5], [8, 10, 3, 4], [9, 1, 2, 3]]","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Check if the edge going from vertex 2 to vertex 10 can be flipped:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> is_flippable(g, 2, 10)\ntrue","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Flip said edge:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> flip!(g, 2, 10)\nTriangulatedPolygon with 10 vertices, and adjacency list:\n[[2, 10, 3], [1, 3], [2, 4, 10, 9, 1], [3, 5, 9, 8], [4, 6, 8, 7], [5, 7], [6, 8, 5], [7, 9, 4, 5], [8, 10, 3, 4], [9, 1, 3]]","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Construct the flipgraph of an Octagon:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> G = flipgraph_planar(8)\nFlipGraphPlanar with 132 vertices and 330 edges","category":"page"},{"location":"quickStart/#Δ-Complex-/-Triangulation-of-closed-surface","page":"Quick Start","title":"Δ-Complex / Triangulation of closed surface","text":"","category":"section"},{"location":"quickStart/#DeltaComplex","page":"Quick Start","title":"DeltaComplex","text":"","category":"section"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"A DeltaComplex is a simplified triangulation on a closed surface. (Can be used to compute things like the diameter etc. But does not offer a unique modelisation of a triangulation on a closed surface)","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Create a DeltaComplex of a surface of genus 1 with 2 points ","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> D = delta_complex(1, 2)\nDeltaComplex on orientable surface of genus 1 with 2 points\n4 TriFaces:\n TriFace #1: Points(1 1 2) Neighbors(2 3 4)\n TriFace #2: Points(1 1 1) Neighbors(4 1 3)\n TriFace #3: Points(1 1 2) Neighbors(2 4 1)\n TriFace #4: Points(1 1 2) Neighbors(2 1 3)\n6 DualEdges:\n DualEdge 1 : (Δ3)-(1)-------(3)-(Δ2)\n DualEdge 2 : (Δ1)-(1)-------(2)-(Δ2)\n DualEdge 3 : (Δ2)-(1)-------(1)-(Δ4)\n DualEdge 4 : (Δ4)-(2)-------(3)-(Δ1)\n DualEdge 5 : (Δ1)-(2)-------(3)-(Δ3)\n DualEdge 6 : (Δ3)-(2)-------(3)-(Δ4)","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Check if the 4th edge (DualEdge 4) can be flipped:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> is_flippable(D, 4)\ntrue","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Flip said edge:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> flip!(D, 4)\nDeltaComplex on orientable surface of genus 1 with 2 points\n4 TriFaces:\n TriFace #1: Points(1 2 1) Neighbors(3 3 4)\n TriFace #2: Points(1 1 1) Neighbors(4 4 3)\n TriFace #3: Points(1 1 2) Neighbors(2 1 1)\n TriFace #4: Points(1 1 1) Neighbors(2 1 2)\n6 DualEdges:\n DualEdge 1 : (Δ3)-(1)-------(3)-(Δ2)\n DualEdge 2 : (Δ4)-(1)-------(2)-(Δ2)\n DualEdge 3 : (Δ2)-(1)-------(3)-(Δ4)\n DualEdge 4 : (Δ4)-(2)-------(3)-(Δ1)\n DualEdge 5 : (Δ1)-(1)-------(3)-(Δ3)\n DualEdge 6 : (Δ3)-(2)-------(2)-(Δ1)","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Randomly flip edges in D until it the diameter stabilizes:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> randomize!(D)\n10300000\njulia> D\nDeltaComplex on orientable surface of genus 1 with 2 points\n4 TriFaces:\n TriFace #1: Points(1 1 1) Neighbors(3 2 2)\n TriFace #2: Points(1 1 1) Neighbors(1 3 1)\n TriFace #3: Points(1 1 1) Neighbors(1 2 4)\n TriFace #4: Points(2 1 1) Neighbors(4 3 4)\n6 DualEdges:\n DualEdge 1 : (Δ3)-(3)-------(2)-(Δ4)\n DualEdge 2 : (Δ3)-(2)-------(2)-(Δ2)\n DualEdge 3 : (Δ4)-(3)-------(1)-(Δ4)\n DualEdge 4 : (Δ1)-(2)-------(3)-(Δ2)\n DualEdge 5 : (Δ1)-(1)-------(1)-(Δ3)\n DualEdge 6 : (Δ2)-(1)-------(3)-(Δ1)","category":"page"},{"location":"quickStart/#HoleyDeltaComplex","page":"Quick Start","title":"HoleyDeltaComplex","text":"","category":"section"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"A DeltaComplex is a more elaborate modelisation of a triangulation on a closed surface. This allows to determine if two triangulisations are homeomorph to each other or not. This comes however at the cost of efficiency.","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> HD = holey_delta_complex(1, 2)\nHoleyDeltaComplex on orientable surface of genus 1 with: 2 Points; 4 TriFaces; \n6 DualEdges; 1 Hole:\nHole 1 : --<--3⤈-1⤈-6⤉--<--","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Construct a local image of the flipgraph containing HD up to a depth of 5.","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> flip_graph(HD, 5)\nFlipGraph with 98 vertices and 154 edges","category":"page"},{"location":"polygonTriangulation/#Triangulations-of-Convex-Polygons","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"","category":"section"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"In order to better understand triangulations, flips and flip graphs, it can be helpful to start simple. If you take any number of points and iteratively connect them with straight edges that do not cross each other  until you can no longer add an edge that does not cross any other edge, what you'll get is a (geometric) triangulation.","category":"page"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"To get from one triangulation of a set of points to another, you may choose an inner edge and flip it.  If you look at any inner edge, the two triangles adjacent to it form a quadrilateral, with the edge as one of its diagonals. To flip an edge, all we have to do is replace it with the other diagonal.  As we don't want to have straight edges that cross each other, a flip can only be done if the quadrilateral is convex and no three of its corners lie on the same line. As we are interested in taking this theory to closed surfaces, where we will no longer have the restriction of edges being straight, we will only consider triangulations of points in convex general position. In this case, a triangulation in the geometric sense is equivalent to a triangulation of points on the border of a disc.","category":"page"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"We do not care where exactly the points are located; however, in order to keep in line with the geometric sense and have a simple visualization, we will consider these points to be the vertices of a convex polygon (i.e. points in convex position). ","category":"page"},{"location":"polygonTriangulation/#Structures","page":"Triangulations of Convex Polygons","title":"Structures","text":"","category":"section"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"    TriangulatedPolygon","category":"page"},{"location":"polygonTriangulation/#FlipGraphs.TriangulatedPolygon","page":"Triangulations of Convex Polygons","title":"FlipGraphs.TriangulatedPolygon","text":"struct TriangulatedPolygon <: AbstractGraph{Int32}\n\nA structure representing a triangulation of a convex polygon.\n\n\n\n\n\n","category":"type"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"TriangulatedPolygon implements the AbstractGraph interface from Graphs.jl. It is therefore possible to use it with other packages that work with Graphs.jl. This is very helpful for plotting the graph.\\\n Vertices are not explicitly stored in TriangulatedPolygon. Only the total number of vertices is stored. They are implicitly labeled by the integers from 1 up to the total number of vertices.","category":"page"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"Edges are stored as an adjacency list of which vertices are connected to another.","category":"page"},{"location":"polygonTriangulation/#Constructors","page":"Triangulations of Convex Polygons","title":"Constructors","text":"","category":"section"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"    triangulated_polygon","category":"page"},{"location":"polygonTriangulation/#FlipGraphs.triangulated_polygon","page":"Triangulations of Convex Polygons","title":"FlipGraphs.triangulated_polygon","text":"triangulated_polygon(n::Integer) :: TriangulatedPolygon\n\nCreate a triangulated convex n-gon. \n\nVertices are named from 1 to n in an anticlockwise manner. The inside is triangulated in a zig-zag pattern.\n\n\n\n\n\n","category":"function"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"As an example, the output of triangulated_polygon(9) would be a graph that corresponds to the following triangulation of a 9-gon:","category":"page"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"(Image: Triangulated 9-gon)","category":"page"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"<p align=\"center\">\n  <img src=\"assets/triPoly-9.png\" width=\"160px\" hspace=\"20\">\n</p>","category":"page"},{"location":"polygonTriangulation/#Graph-Methods","page":"Triangulations of Convex Polygons","title":"Graph Methods","text":"","category":"section"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"    nv(::TriangulatedPolygon)\n    ne(::TriangulatedPolygon)\n    vertices(::TriangulatedPolygon)\n    edges(::TriangulatedPolygon)\n    has_vertex(::TriangulatedPolygon, v)\n    \n    has_edge(::TriangulatedPolygon, e::Edge)\n    has_edge(::TriangulatedPolygon, s, d)\n\n    neighbors(::TriangulatedPolygon, ::Integer)\n    degrees(::TriangulatedPolygon)\n    is_isomorphic(::FGPVertex, ::TriangulatedPolygon, ::Array{Vector{Integer},1})\n    rename_vertices(::TriangulatedPolygon, ::Vector{Integer})\n    adjacency_matrix(::TriangulatedPolygon)","category":"page"},{"location":"polygonTriangulation/#Graphs.nv-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"Graphs.nv","text":"nv(g::TriangulatedPolygon) :: Int\n\nReturn the number of vertices/points in g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.ne-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"Graphs.ne","text":"ne(g::TriangulatedPolygon) :: Int\n\nReturn the number of edges in g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.vertices-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"Graphs.vertices","text":"vertices(g::TriangulatedPolygon) :: Vector{Int}\n\nReturn a list of all the vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.edges-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"Graphs.edges","text":"edges(g::TriangulatedPolygon) :: Vector{SimpleEdge{Int32}}\n\nCompute and return a list of all the edges in g.\n\nEdges are not directed. It is, however, necessary for computations to define a source and a target.  For TriangulatedPolygon, the source will be the incident vertex with the smaller id.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.has_vertex-Tuple{TriangulatedPolygon, Any}","page":"Triangulations of Convex Polygons","title":"Graphs.has_vertex","text":"has_vertex(g::TriangulatedPolygon, v::Integer)\n\nReturn true if v is a vertex in g. \n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.has_edge-Tuple{TriangulatedPolygon, Graphs.SimpleGraphs.SimpleEdge}","page":"Triangulations of Convex Polygons","title":"Graphs.has_edge","text":"has_edge(g::TriangulatedPolygon, e::Edge)\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.has_edge-Tuple{TriangulatedPolygon, Any, Any}","page":"Triangulations of Convex Polygons","title":"Graphs.has_edge","text":"has_edge(g::TriangulatedPolygon, s::Integer, d::Integer)\n\nReturn true if g has an edge going from vertex s to vertex d. \n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.neighbors-Tuple{TriangulatedPolygon, Integer}","page":"Triangulations of Convex Polygons","title":"Graphs.neighbors","text":"neighbors(g::TriangulatedPolygon, v::Integer) :: Vector{Int32}\n\nReturn the list of all the vertices in g that are adjacent to v.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.degrees-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.degrees","text":"degrees(g::TriangulatedPolygon) -> Vector{Int}\n\nReturn a list of the degrees of every single vertex in g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.is_isomorphic-Tuple{FGPVertex, TriangulatedPolygon, Vector{Vector{Integer}}}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.is_isomorphic","text":"is_isomorphic(g1::FGPVertex, g2::TriangulatedPolygon, permutations::Vector{Vector{T}}) where T<:Integer\n\nCheck if g2 is isomorphic to g1 up to a relabeling of the vertices by one of the permutations.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.rename_vertices-Tuple{TriangulatedPolygon, Vector{Integer}}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.rename_vertices","text":"rename_vertices(g::TriangulatedPolygon, p::Vector{<:Integer})\n\nRename the vertices of g by applying the permutation p.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.adjacency_matrix-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.adjacency_matrix","text":"adjacency_matrix(g::TriangulatedPolygon) :: Matrix{Int32}\n\nCompute the adjacency matrix for the triangulated graph g. \n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Flipping","page":"Triangulations of Convex Polygons","title":"Flipping","text":"","category":"section"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"    is_flippable(::TriangulatedPolygon, ::Integer, ::Integer)\n    is_flippable(::TriangulatedPolygon, ::Edge)\n    flip!(::TriangulatedPolygon, ::Integer, ::Integer)\n    flip!(::TriangulatedPolygon, ::Edge)\n    flip(::TriangulatedPolygon, ::Edge)","category":"page"},{"location":"polygonTriangulation/#FlipGraphs.is_flippable-Tuple{TriangulatedPolygon, Integer, Integer}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.is_flippable","text":"is_flippable(g::TriangulatedPolygon, src::Integer, dst::Integer) :: Bool\n\nReturn whether or not the edge can be flipped.\n\nNote that for a triangulation of a convex polygon, the inner edges are always flippable,      while the outer edges cannot be flipped.    \n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.is_flippable-Tuple{TriangulatedPolygon, Graphs.SimpleGraphs.SimpleEdge}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.is_flippable","text":"is_flippable(g::TriangulatedPolygon, e::Edge) ::Bool\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.flip!-Tuple{TriangulatedPolygon, Integer, Integer}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.flip!","text":"flip!(g::TriangulatedPolygon, src::Integer, dst::Integer) :: TriangulatedPolygon\n\nFlip the the edge incident to src and dst in g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.flip!-Tuple{TriangulatedPolygon, Graphs.SimpleGraphs.SimpleEdge}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.flip!","text":"flip!(g::TriangulatedPolygon, e::Edge) :: TriangulatedPolygon\n\nFlip e in g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.flip-Tuple{TriangulatedPolygon, Graphs.SimpleGraphs.SimpleEdge}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.flip","text":"flip(g::TriangulatedPolygon, e::Edge) :: TriangulatedPolygon\n\nReturn the triangulated polygon obtained by flipping the edge e in g.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#DeltaComplexes","page":"DeltaComplexes","title":"DeltaComplexes","text":"","category":"section"},{"location":"deltaComplex/#Modelling-a-triangulation-on-a-closed-surface","page":"DeltaComplexes","title":"Modelling a triangulation on a closed surface","text":"","category":"section"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"A Δ-complex is a representation of a triangulation on a closed surface. To define a triangulation on a closed surface, it does not suffice to take into account vertices and edges. We will also need to take into account the triangular faces between them. Therefore the triangulations are modeled using an extension of their dual graph.","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"Vertices are triangular faces which in turn consist of three points, and three edges. These points and edges are not necessarily distinct. Edges in the dual Graph(i.e. the Δ-complex) connect two triangular faces if they in turn share an edge. In order to avoid confusion between the edges of the triangulation and the edges in the dual graph, I will, hence forwards call the latter dual edge.","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    DeltaComplex\n    DualEdge\n    TriFace","category":"page"},{"location":"deltaComplex/#FlipGraphs.DeltaComplex","page":"DeltaComplexes","title":"FlipGraphs.DeltaComplex","text":"struct DeltaComplex\n\nA Graph datastructure representing a triangulation of a surface.\n\nThe DeltaComplex may be thought of as the dual of a triangulation.\n\nVertices are triangular faces (TriFace). Every vertex has three edges (DualEdge) incident to it.\n\n\n\n\n\n","category":"type"},{"location":"deltaComplex/#FlipGraphs.DualEdge","page":"DeltaComplexes","title":"FlipGraphs.DualEdge","text":"struct DualEdge\n\nRepresentation of an edge in a DeltaComplex (i.e. the dual graph of a triangulation).\n\nA DualEdge connects two TriFaces through specific sides.\n\n\n\n\n\n","category":"type"},{"location":"deltaComplex/#FlipGraphs.TriFace","page":"DeltaComplexes","title":"FlipGraphs.TriFace","text":"struct TriFace\n\nA TriFace represents a triangle in the triangulization of a surface. \n\nThe TriFace's form the vertices of a DeltaComplex. Each TriFace is formed between 3 points and is connected to 3 Trifaces through DualEdges. The points and neighboring triangles do not have to be unique.\n\nThe points and edges are stored in an anticlockwise order.\nThe first edge/side is between the first and second point.\nThe second edge/side is between the second and third point.\nThe third edge/side is between the third and first point.\n\n\n\n\n\n\n","category":"type"},{"location":"deltaComplex/#Construction-of-a-DeltaComplex","page":"DeltaComplexes","title":"Construction of a DeltaComplex","text":"","category":"section"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"This Module comes with some handy and easy to use tools to construct a triangulation of a surface:","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    deltacomplex\n    deltacomplex_non_orientable\n    subdivide!(::DeltaComplex, ::Integer)","category":"page"},{"location":"deltaComplex/#FlipGraphs.deltacomplex","page":"DeltaComplexes","title":"FlipGraphs.deltacomplex","text":"deltacomplex(genus , num_points = 1)\n\nCreate a triangulation of an orientable surface with num_points points on it. \n\nBy default num_points is set to 1.\n\n\n\n\n\ndeltacomplex(s :: Array{<:Integer,1})\n\nCreate a triangulation of an orientable surface with a single point, by gluing corresponding edges together.\n s should be an array of nonzero integers representing the edges of a polygon in anticlockwise order.\\  The i-th edge is orientated anticlockwise if s[i]>0 and anticlockwise if s[i]<0.\nIf s[i] and s[j] have the same absolute value, they are glued together while respecting their orientation.\n #Examples The following results in the triangulation of a torus with one point:\n\njulia> deltacomplex([1,2,-1,-2])\n\nThe following results in the triangulation of a Klein bottle with one point:\n\njulia> deltacomplex([1,2,-1,-2])\n\n\n\n\n\n","category":"function"},{"location":"deltaComplex/#FlipGraphs.deltacomplex_non_orientable","page":"DeltaComplexes","title":"FlipGraphs.deltacomplex_non_orientable","text":"deltacomplex_non_orientable(demigenus , num_points = demigenus+1)\n\nCreate a triangulation of a non-orientable surface with num_points points on it. \n\nBy default num_points is set to 1.\n\n\n\n\n\n","category":"function"},{"location":"deltaComplex/#FlipGraphs.subdivide!-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"FlipGraphs.subdivide!","text":"subdivide!(D::DeltaComplex, t::Integer)\n\nAdd a point to the inside of the t-th TriFace and connect it to each corner.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Common-Graph-like-methods","page":"DeltaComplexes","title":"Common Graph-like methods","text":"","category":"section"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"DeltaComplex is not an implementation of Graphs.AbstractGraph. However, as it is similar to a simple graph, I used the same notation and function names for simplicity","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    np(::DeltaComplex)\n    nv(::DeltaComplex)\n    ne(::DeltaComplex)\n    vertices(::DeltaComplex)\n    get_vertex(::DeltaComplex, ::Integer)\n    get_vertex_id(::DualEdge, ::Integer)\n    edges(::DeltaComplex)\n    get_edge(::DeltaComplex, ::Integer)\n    get_edge(::DeltaComplex, ::Integer, ::Integer)\n    id(::DualEdge)\n\n    points(::TriFace)\n    get_point(::TriFace, ::Integer)\n    points(::DeltaComplex, ::DualEdge)\n\n    vertices(::DeltaComplex, ::DualEdge)\n    vertices_id(::DualEdge)\n\n    get_edge(::TriFace, ::Integer) \n    get_edge_id(::TriFace, ::Integer)\n    edges(::TriFace)\n    edges(::DeltaComplex, ::Integer)\n    edges_id(::DeltaComplex, ::Integer) \n    edges_id(::TriFace) \n    id(::TriFace) \n\n    other_endpoint(::DualEdge, ::Integer, ::Integer)\n    is_similar(::DualEdge, ::DualEdge)","category":"page"},{"location":"deltaComplex/#FlipGraphs.np-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.np","text":"np(D::DeltaComplex)\n\nReturn the number of points in the triangulation defined by D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.nv-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"Graphs.nv","text":"nv(D::DeltaComplex)\n\nReturn the number of vertices(i.e. triangular faces) in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.ne-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"Graphs.ne","text":"ne(D::DeltaComplex)\n\nReturn the number of edges in the DeltaComplex D.\n\nThis is equal to the number of edges in the triangulation itself.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.vertices-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"Graphs.vertices","text":"vertices(D::DeltaComplex) -> Vector{TriFace}\n\nReturn the list of all vertices in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_vertex-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"FlipGraphs.get_vertex","text":"get_vertex(D::DeltaComplex, t::Integer) -> TriFace\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_vertex_id-Tuple{DualEdge, Integer}","page":"DeltaComplexes","title":"FlipGraphs.get_vertex_id","text":"get_vertex_id(d::DualEdge, side::Integer) -> Int\n\nReturn the index of the vertex (TriFace) to the left ofd`.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.edges-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"Graphs.edges","text":"edges(D::DeltaComplex) -> Vector{DualEdge}\n\nReturn the list of all the DualEdges in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_edge-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"FlipGraphs.get_edge","text":"get_edge(D::DeltaComplex, e::Integer) -> DualEdge\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_edge-Tuple{DeltaComplex, Integer, Integer}","page":"DeltaComplexes","title":"FlipGraphs.get_edge","text":"get_edge(D::DeltaComplex, t::Integer, side::Integer) -> DualEdge\n\nReturn the edge that forms the respective side in the given triangle t.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.id-Tuple{DualEdge}","page":"DeltaComplexes","title":"FlipGraphs.id","text":"id(d::DualEdge) -> Int\n\nReturn the index of d in its DeltaComplex.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.points-Tuple{TriFace}","page":"DeltaComplexes","title":"FlipGraphs.points","text":"points(T::TriFace) -> Tuple{Int, Int, Int}\n\nReturn a tuple of the three points, that form the corners of T.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_point-Tuple{TriFace, Integer}","page":"DeltaComplexes","title":"FlipGraphs.get_point","text":"get_point(T::TriFace, corner::Integer) -> Int\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.points-Tuple{DeltaComplex, DualEdge}","page":"DeltaComplexes","title":"FlipGraphs.points","text":"points(D::DeltaComplex, d::DualEdge) -> Tuple{Int, Int}\n\nReturn both endpoints of d in the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.vertices-Tuple{DeltaComplex, DualEdge}","page":"DeltaComplexes","title":"Graphs.vertices","text":"vertices(D::DeltaComplex, d::DualEdge) -> Tuple{TriFace, TriFace}\n\nReturn both vertices adjacent to d.\n\nThe first TriFace is on the left of the edge, and the second one on the right of the edge.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.vertices_id-Tuple{DualEdge}","page":"DeltaComplexes","title":"FlipGraphs.vertices_id","text":"vertices_id(d::DualEdge) -> Tuple{Int, Int}\n\nReturn the indices of both vertices (TriFaces) adjacent to d.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_edge-Tuple{TriFace, Integer}","page":"DeltaComplexes","title":"FlipGraphs.get_edge","text":"get_edge(T::TriFace, side::Integer) -> DualEdge\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_edge_id-Tuple{TriFace, Integer}","page":"DeltaComplexes","title":"FlipGraphs.get_edge_id","text":"get_edge_id(T::TriFace, side::Integer) -> Integer\n\nReturn the index of the edge on the respective side in T.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.edges-Tuple{TriFace}","page":"DeltaComplexes","title":"Graphs.edges","text":"edges(T::TriFace) -> Vector{DualEdge}\n\nReturn the list of all 3 edges that are incident to T. \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.edges-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"Graphs.edges","text":"edges(D::DeltaComplex, t::Integer) -> Vector{DualEdge}\n\nReturn the list of all 3 edges that are incident to the t-th Triface in D. \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.edges_id-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"FlipGraphs.edges_id","text":"edges_id(D::DeltaComplex, t::Integer) -> Tuple{Int, Int, Int}\n\nReturn the indices of all 3 edges that are incident to T. \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.edges_id-Tuple{TriFace}","page":"DeltaComplexes","title":"FlipGraphs.edges_id","text":"edges_id(T::TriFace) -> Tuple{Int, Int, Int}\n\nReturn the indices of all 3 edges that are incident to T. \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.id-Tuple{TriFace}","page":"DeltaComplexes","title":"FlipGraphs.id","text":"id(T::TriFace)\n\nReturn the index of T in its DeltaComplex. \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.other_endpoint-Tuple{DualEdge, Integer, Integer}","page":"DeltaComplexes","title":"FlipGraphs.other_endpoint","text":"other_endpoint(d::DualEdge, t::Integer, side::Integer) -> Tuple{Int, Int8}\n\nReturn the index of the other TriFace and its respective side, that is incident to d \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.is_similar-Tuple{DualEdge, DualEdge}","page":"DeltaComplexes","title":"FlipGraphs.is_similar","text":"is_similar(d1::DualEdge, d2::DualEdge) -> Bool\n\nReturn true if d1 and d2 have the same twist and are connected to the same triangles.\n\nThis is only the case if d1 and d2 are the same edge, or if they are incident to a point of degree 2.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Classifying-the-triangulation","page":"DeltaComplexes","title":"Classifying the triangulation","text":"","category":"section"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"Here are some usefull methods, to pull out general information about the Δ-Complex, and the triangulation it represents:","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    euler_characteristic(::DeltaComplex)\n    genus(::DeltaComplex)\n    diameter_triangulation(::DeltaComplex)\n    diameter_deltaComplex(::DeltaComplex)\n    diameter(::DeltaComplex)\n    adjacency_matrix_deltacomplex(::DeltaComplex)\n    adjacency_matrix_triangulation(::DeltaComplex)\n    multi_adjacency_matrix_triangulation(::DeltaComplex)","category":"page"},{"location":"deltaComplex/#FlipGraphs.euler_characteristic-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.euler_characteristic","text":"euler_characteristic(D::DeltaComplex)\n\nCompute the euler characteristic of the DeltaComplex D:\nX = vertices - edges + faces\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.genus-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.genus","text":"genus(D::DeltaComplex)\n\nCompute the genus of the DeltaComplex D if it forms an orientable surface.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.diameter_triangulation-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.diameter_triangulation","text":"diameter_triangulation(D::DeltaComplex)\n\nCompute the diameter of the triangulation defined by the DeltaComplex D.\n\nThe diameter of a Graph is the greatest minimal distance between any 2 vertices.\n\nSee also diameter_deltaComplex\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.diameter_deltaComplex-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.diameter_deltaComplex","text":"diameter_deltacomplex(D::DeltaComplex)\n\nCompute the diameter of the DeltaComplex D.\n The diameter of a Graph is the greatest minimal distance between any 2 vertices.\n\nSee also diameter_triangulation\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.diameter-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"Graphs.diameter","text":"diameter(D::DeltaComplex)\n\nCompute the diameter of the DeltaComplex D.\n The diameter of a Graph is the greatest minimal distance between any 2 vertices.\n\nSee also diameter_triangulation\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.adjacency_matrix_deltacomplex-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.adjacency_matrix_deltacomplex","text":"adjacency_matrix_deltacomplex(D::DeltaComplex) :: Matrix{<:Integer}\n\nCompute the adjacency matrix of the delta complex D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.adjacency_matrix_triangulation-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.adjacency_matrix_triangulation","text":"adjacency_matrix_triangulation(D::DeltaComplex) :: Matrix{Int}\n\nCompute the simple adjacency matrix of the triangulation defined by D.\n\nAll entries are either 0 or 1.\n\nSee also multi_adjacency_matrix_triangulation\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.multi_adjacency_matrix_triangulation-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.multi_adjacency_matrix_triangulation","text":"multi_adjacency_matrix_triangulation(D::DeltaComplex) :: Matrix{Int}\n\nCompute the adjacency matrix of the multigraph of the triangulation defined by D.\n\nThe i,j-th entry not only notes if both points are connected,  but also the number of edges that connect these two points.\n\nSee also adjacency_matrix_triangulation\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    point_degrees(::DeltaComplex)","category":"page"},{"location":"deltaComplex/#FlipGraphs.point_degrees-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.point_degrees","text":"point_degrees(D::DeltaComplex) -> Vector{<:Integer}\n\nReturn a vector containing the respective degree of each point in the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    rename_edges!(::DeltaComplex, ::Vector{<:Integer})\n    rename_points!(D::DeltaComplex, p::Vector{<:Integer})\n    rename_vertices!(::DeltaComplex, ::Vector{<:Integer})","category":"page"},{"location":"deltaComplex/#FlipGraphs.rename_edges!-Tuple{DeltaComplex, Vector{var\"#s1\"} where var\"#s1\"<:Integer}","page":"DeltaComplexes","title":"FlipGraphs.rename_edges!","text":"rename_edges!(D::DeltaComplex, p::Vector{<:Integer})\n\nRename every vertex(TriFace) in D, according to the permutation p.\n\nTriFace 1 => TriFace p[1]\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.rename_points!-Tuple{DeltaComplex, Vector{var\"#s1\"} where var\"#s1\"<:Integer}","page":"DeltaComplexes","title":"FlipGraphs.rename_points!","text":"rename_points!(D::DeltaComplex, p::Vector{<:Integer})\n\nRename all the points in D according to the permutation p.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.rename_vertices!-Tuple{DeltaComplex, Vector{var\"#s1\"} where var\"#s1\"<:Integer}","page":"DeltaComplexes","title":"FlipGraphs.rename_vertices!","text":"rename_vertices!(D::DeltaComplex, p::Vector{<:Integer})\n\nRename every vertex(TriFace) in D, according to the permutation p.\n\nTriFace 1 => TriFace p[1]\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Non-orientable-closed-surfaces","page":"DeltaComplexes","title":"Non-orientable closed surfaces","text":"","category":"section"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"Regarding on which way edges are glued together, the resulting surface may be non-orientable. These surfaces can also be modeled by DeltaComplex and all of the methods above (with the exception of genus) may still be applied.","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    is_orientable(::DeltaComplex)\n    demigenus\n    twist_edges!","category":"page"},{"location":"deltaComplex/#FlipGraphs.is_orientable-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.is_orientable","text":"is_orientable(D::DeltaComplex)\n\nCkeck if the surface on which D lies is orientable or not.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.demigenus","page":"DeltaComplexes","title":"FlipGraphs.demigenus","text":"demigenus(D::DeltaComplex)\n\nCompute the demigenus of the DeltaComplex D.\n The demigenus or non-orientable genus (k) of a connected non-orientable closed surface is defined via the euler characteristic ()X) :\nk = 2 - X\n\n\n\n\n\n","category":"function"},{"location":"deltaComplex/#FlipGraphs.twist_edges!","page":"DeltaComplexes","title":"FlipGraphs.twist_edges!","text":"twist_edges!(D::DeltaComplex, t::Integer)\ntwist_edges!(T::TriFace)\n\nTwist or untwist all 3 edges in a TriFace, and reverse the side order.\n\nThis action gives an equivalent representation ot the same triangulation. It is usefull in the case that you would like to untwist a certain edge.\n\nExamples\n\njulia> D = deltacomplex([1,2,-1,2]);\njulia> T = get_vertex(D,1);\njulia> edges(T)\n3-element Array{DualEdge,1}:\n DualEdge 2 : (Δ1)-(1)-------(2)-(Δ2)\n DualEdge 1 : (Δ1)-(2)-------(3)-(Δ2)\n DualEdge 3 : (Δ2)-(1)---↺---(3)-(Δ1)\n julia> twist_edges!(T);\n julia> edges(T)\n 3-element Array{DualEdge,1}:\n DualEdge 3 : (Δ2)-(1)-------(1)-(Δ1)\n DualEdge 1 : (Δ1)-(2)---↺---(3)-(Δ2)\n DualEdge 2 : (Δ1)-(3)---↺---(2)-(Δ2)\n\n\n\n\n\n","category":"function"},{"location":"deltaComplex/#Flipping","page":"DeltaComplexes","title":"Flipping","text":"","category":"section"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"A flip is defined as the action of replacing an edge in the triangulation by the other diagonal of the quadrilateral formed by the two triangles adjacent to the edge.","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"It has been shown, that the flipgraph of any closed surface is connected, hence it is possible, to obtain any triangulation by a finite number of flips.","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    flip(::DeltaComplex, ::Integer)\n    flip!(::DeltaComplex, ::Integer)\n    flip!(::DeltaComplex, ::DualEdge; ::Bool)\n    is_flippable(::DeltaComplex, ::Integer)\n    is_flippable(::DualEdge)\n    random_flips!(::DeltaComplex, ::Integer)\n    randomize!(::DeltaComplex; ::Integer, ::Integer, ::Integer, ::Integer)","category":"page"},{"location":"deltaComplex/#FlipGraphs.flip-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"FlipGraphs.flip","text":"flip(D::DeltaComplex, e::Integer)\n\nReturn the resulting DeltaComplex obtained by flipping the given edge in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.flip!-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"FlipGraphs.flip!","text":"flip!(D::DeltaComplex, e::Integer)\n\nFlip, if possible, the given edge in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.flip!-Tuple{DeltaComplex, DualEdge}","page":"DeltaComplexes","title":"FlipGraphs.flip!","text":"flip!(D::DeltaComplex, d::DualEdge)\n\nFlip, if possible, the given edge in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.is_flippable-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"FlipGraphs.is_flippable","text":"is_flippable(D::DeltaComplex, e::Integer)\n\nReturn true if the given edge can be flipped.\n\nThis is always the case if the edge does not connect a TriFace to itself.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.is_flippable-Tuple{DualEdge}","page":"DeltaComplexes","title":"FlipGraphs.is_flippable","text":"is_flippable(d::DualEdge)\n\nReturn true if the given edge is can be flipped.\n\nThis is always the case if the edge does not connect a TriFace to itself.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.random_flips!-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"FlipGraphs.random_flips!","text":"random_flips!(D::DeltaComplex, n::Integer)\n\nRandomly pick an edge, and flip it if possible. Repeat this n times.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.randomize!-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.randomize!","text":"randomize!(D::DeltaComplex; kwargs...) -> Int\n\nRandomly flip edges in D until D is sufficiently generic.\n\nReturn the number of attempted flips.\n\nThe measure by which we determin if D is sufficiently generic is through its diameter. This Method repeatedly flips a certain number of times. After each flip sequence the diameter is computed. Once this was repeated a certain number of times, the variance of all these past diameter measurements gets computed.\n\nIn theory, the variance should diminish over time. However, as we are flipping randomly, it will never truly converge to 0. A certain flutter in the variance is expected, this will at some point cause the variance to increase every so often. The algorithm stops once the last measured variance is bigger than the past few measurements.\n\nArguments\n\nnum_initial_flips::Integer=1000000 : the number of flips to do before even start taking measurements.\nnum_flips_per_step::Integer=10000 : the number of flips to do before computing the diameter each step.\nvariance_interval_size::Integer=10 : the number of diameters to store, before computing their variance. \nlookback_size::Integer=2 : how far back to compare the current variance to, in order to decide when to stop. \n\nExamples\n\njulia> D = deltacomplex(30,30);\njulia> randomize!(D, num_initial_flips=10000, num_flips_per_step = 1000, variance_interval_size=10, lookback_size = 5)\n160000\n\n\n\n\n\n","category":"method"},{"location":"flipGraph_planar/#Flip-Graphs-of-Convex-Polygons","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"","category":"section"},{"location":"flipGraph_planar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"Flip Graphs, are obtained, by considering triangulations on a fixed set of points as vertices, and connect two vertices,  if it is possible to get from one triangulation to the other by flipping a single edge.","category":"page"},{"location":"flipGraph_planar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"    FlipGraphPlanar","category":"page"},{"location":"flipGraph_planar/#FlipGraphs.FlipGraphPlanar","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.FlipGraphPlanar","text":"struct FlipGraphPlanar <: AbstractGraph{Int32}\n\nA Graph representing the FlipGraph of a convex polygon. \n\nVertices are different triangulations of the same convex polygon.\n\nTwo vertices are linked by an edge, if the respective graphs differ only by a single flip.\n\n\n\n\n\n","category":"type"},{"location":"flipGraph_planar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"FlipGraphPlanar implements the AbstractGraph interface from Graphs.jl. It is therefore possible to use it with other packages that work with Graphs.jl. This is very helpfull for plotting the graph.","category":"page"},{"location":"flipGraph_planar/#Constructors","page":"Flip Graphs of Convex Polygons","title":"Constructors","text":"","category":"section"},{"location":"flipGraph_planar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"    flipgraph(::TriangulatedPolygon)\n    flipgraph_planar","category":"page"},{"location":"flipGraph_planar/#FlipGraphs.flipgraph-Tuple{TriangulatedPolygon}","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.flipgraph","text":"flipgraph(g::TriangulatedPolygon; kwargs..)\n\nConstruct the FlipGraph for the TriangulatedPolygon g.\n\nArguments\n\n'modular::Bool = false' : by default the whole flip graph is constructed. If modular is set to true, then only the modular flip graph is constructed.\n\nIn a modular flip graph, vertices of the FlipGraph are classes of isomorphisms up to renaming the vertices.  Each class is then represented by one of its elements.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph_planar/#FlipGraphs.flipgraph_planar","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.flipgraph_planar","text":"flipgraph_planar(n::Integer; modular=false) :: FlipGraphPlanar\n\nConstruct the FlipGraphPlanar of a convex n-gon. \n\nIf modular=true, the FlipGraph is reduced to its modular form.\n\nExamples\n\njulia> flipgraph_planar(6)\nFlipGraphPlanar with 14 vertices and 21 edges\n\n\n\n\n\n","category":"function"},{"location":"flipGraph_planar/#Graph-methods","page":"Flip Graphs of Convex Polygons","title":"Graph methods","text":"","category":"section"},{"location":"flipGraph_planar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"@docs     nv(::FlipGraphPlanar)     ne(::FlipGraphPlanar)     vertices(::FlipGraphPlanar)     edges(::FlipGraphPlanar)     has_vertex(::FlipGraphPlanar,v)     has_edge(::FlipGraphPlanar,s,d)     has_edge(::FlipGraphPlanar,::Edge)     neighbors(::FlipGraphPlanar, ::Integer)     diameter(::FlipGraphPlanar)","category":"page"},{"location":"exporting/#Exporting","page":"Exporting","title":"Exporting","text":"","category":"section"},{"location":"exporting/","page":"Exporting","title":"Exporting","text":"    export_gml","category":"page"},{"location":"exporting/#FlipGraphs.export_gml","page":"Exporting","title":"FlipGraphs.export_gml","text":"export_gml(fpn::String, G::AbstractGraph{::Integer})\n\nSave the graph G as a .gml file.\n\nG can be either a FlipGraph or FlipGraphPlanar.\n\nExample\n\njulia> G = flipgraph_planar(10);\njulia> export_gml(\"C:/Users/USERNAME/Desktop/filename.gml\", G);\n\n\n\n\n\n","category":"function"},{"location":"flipGraph/#FlipGraph","page":"FlipGraph","title":"FlipGraph","text":"","category":"section"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"Contrary to flipgraphs of planar triangulations like that of a convex polygon, the flipgraph of a closed surface is generally infinitely large. Therefore, it is impossible to construct the whole flipgraph. Not only are they infinitely in size, but they also \"grow\" very fast. It is therefore more interesting and achievable, to look at the modular flip graphs. These are graphs whose vertices are isotopy classes of triangulations.","category":"page"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"    FlipGraph\n    FGVertex\n    nv(::FlipGraph)\n    ne(::FlipGraph)\n    vertices(::FlipGraph)\n    edges(::FlipGraph)\n    has_vertex(::FlipGraph, ::Integer)\n    has_edge(::FlipGraph,::Edge)\n    has_edge(::FlipGraph,::Integer, ::Integer)\n    neighbors(::FlipGraph, ::Integer)\n    diameter(::FlipGraph)","category":"page"},{"location":"flipGraph/#FlipGraphs.FlipGraph","page":"FlipGraph","title":"FlipGraphs.FlipGraph","text":"struct FlipGraph <: AbstractGraph{Int}\n\nA Graph representing the flipgraph of a Δ-Complex.\n\nVertices are different triangulations of the same surface.\nTwo vertices are linked by an edge, if the respective graphs differ only by a single flip.\n\n\n\n\n\n","category":"type"},{"location":"flipGraph/#FlipGraphs.FGVertex","page":"FlipGraph","title":"FlipGraphs.FGVertex","text":"struct FGVertex\n\nA vertex in a flip graph. \n\nAn FGVertex is composed of a representant(DeltaComplex) of the isotopy class of that vertex.  The representant has been relabeld with one of the canonical labelings obtained by McKay's Algorithm. Addidtionally, the FGVertex contains the number of labelings that are output by the respective McKay's Algorithms.\n\n\n\n\n\n","category":"type"},{"location":"flipGraph/#Graphs.nv-Tuple{FlipGraph}","page":"FlipGraph","title":"Graphs.nv","text":"nv(G::FlipGraph) -> Int\n\nReturn the number of vertices in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.ne-Tuple{FlipGraph}","page":"FlipGraph","title":"Graphs.ne","text":"ne(G::FlipGraph) -> Int\n\nReturn the number of edges in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.vertices-Tuple{FlipGraph}","page":"FlipGraph","title":"Graphs.vertices","text":"vertices(G::FlipGraph) -> Vector{DeltaComplex}\n\nReturn a list of all the vertices that have been constructed in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.edges-Tuple{FlipGraph}","page":"FlipGraph","title":"Graphs.edges","text":"edges(G::FlipGraph) ::Vector{Edge}\n\nConstruct an array containing all the edges in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.has_vertex-Tuple{FlipGraph, Integer}","page":"FlipGraph","title":"Graphs.has_vertex","text":"has_vertex(G::FlipGraph, v::Integer) -> Bool\n\nReturn true if v is a valid index of a vertex in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.has_edge-Tuple{FlipGraph, Graphs.SimpleGraphs.SimpleEdge}","page":"FlipGraph","title":"Graphs.has_edge","text":"has_edge(G::FlipGraph, e::Edge) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.has_edge-Tuple{FlipGraph, Integer, Integer}","page":"FlipGraph","title":"Graphs.has_edge","text":"has_edge(G::FlipGraph, s::Integer, d::Integer) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.neighbors-Tuple{FlipGraph, Integer}","page":"FlipGraph","title":"Graphs.neighbors","text":"neighbors(G::FlipGraph, v::Integer) -> Vector{Int}\n\nReturn a list of the indices of all the neighboring vertices of the v-th vertex.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.diameter-Tuple{FlipGraph}","page":"FlipGraph","title":"Graphs.diameter","text":"diameter(G::FlipGraph)\n\nReturn the diameter of the portion of the flipgraph that has been constructed.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Comparing-Triangulations","page":"FlipGraph","title":"Comparing Triangulations","text":"","category":"section"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"One problem of deciding, if two triangulations are equivalent, is that the naming of the vertices, edges and points is completely arbitrary. In the act of flipping, DualEdges and TriFaces \"move around\". It is therefore possible, to obtain two HoleyDeltaComplexs representing the same triangulation of a surface but with different labeled TriFaces and DualEdges.  Checking every possible permutation of TriFace and DualEdge labelings is not an option, as the number of possibilities would blow up immeadiately. ","category":"page"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"What we do instead, is trying to find a canonical labeling. This Module uses a version of McKay's canonical graph labeling algorithm[1] to try and determin a unique labeling based on the relationship to other vertices and edges. In general, it is not always possible to determin a unique labeling.However, with this method, we can reduce the number of labelings to a manageable number.","category":"page"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"The mcKay Methods each return a permutation vector p which can be interpreted as Cauchy's one-line notation for permutations.  For example p = [3,5,1,2,6,4] would correspond to the following permutation:","category":"page"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"centering\nσ = beginpmatrix\n1  2  3  4  5  6\n3  5  1  2  6  4\nendpmatrix = (1 3)(2 5 6 4)","category":"page"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"    mcKay_points(::DeltaComplex; ::Bool)\n    mcKay_vertices(::DeltaComplex; ::Bool)\n    mcKay_edges(::DeltaComplex; ::Bool)\n\n    is_isomorphic(::DeltaComplex, ::DeltaComplex)\n    is_isomorphic(candidate::FGVertexCandidate, fgv::FGVertex)","category":"page"},{"location":"flipGraph/#FlipGraphs.mcKay_points-Tuple{DeltaComplex}","page":"FlipGraph","title":"FlipGraphs.mcKay_points","text":"mcKay_points(D::DeltaComplex; only_one::Bool=false)::Vector{Vector{Int}}\n\nApply a version of McKay's canonical graph labeling algorithm in order to determine all possible permutations  of the points which give a canonical isomorphism class representant.\n\nReturn a vector of permutation vectors p such that Point 1 becomes Point p[1], Point 2 becomes Point p[2],... If only_one=true, the algorithm stops after finding one valid permutation.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#FlipGraphs.mcKay_vertices-Tuple{DeltaComplex}","page":"FlipGraph","title":"FlipGraphs.mcKay_vertices","text":"mcKay_vertices(D::DeltaComplex)::Vector{Vector{Int}}\n\nApply a version of McKay's canonical graph labeling algorithm in order to determine all possible permutations  of the triFaces which give a canonical isomorphism class representant.\n\nReturn a vector of permutation vectors p such that TriFace 1 becomes TriFace p[1], TriFace 2 becomes TriFace p[2],...\nIf only_one=true, the algorithm stops after finding one valid permutation.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#FlipGraphs.mcKay_edges-Tuple{DeltaComplex}","page":"FlipGraph","title":"FlipGraphs.mcKay_edges","text":"mcKay_edges(D::DeltaComplex; only_one::Bool=false)::Vector{Vector{Int}}\n\nApply McKay's canonical graph labeling algorithm in order to determine all possible permutations  of the triFaces which give a canonical isomorphism class representant.\n\nReturn a vector of permutation vectors p such that DualEdge 1 becomes DualEdge p[1], DualEdge 2 becomes DualEdge p[2],...\nIf only_one=true, the algorithm stops after finding one valid permutation.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#FlipGraphs.is_isomorphic-Tuple{DeltaComplex, DeltaComplex}","page":"FlipGraph","title":"FlipGraphs.is_isomorphic","text":"is_isomorphic(D1::DeltaComplex, D2::DeltaComplex; kwargs..) -> Bool\n\nReturn true if D1 is isomorph to D2 up to a renaming of the vertices, edges and if fix_points=false also points.\n\nArguments\n\nfix_points::Bool=true : If fix_points is set to false, then the isomorphism also includes a renaming of the points. \n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#FlipGraphs.is_isomorphic-Tuple{FGVertexCandidate, FGVertex}","page":"FlipGraph","title":"FlipGraphs.is_isomorphic","text":"is_isomorphic(candidate::FGVertexCandidate, fgv::FGVertex; kwargs...) -> Bool\n\nReturn true if candidate is in the isotopy class of fgv. \n\nArguments\n\nfix_points::Bool=true : If is set to false, then the isomorphism would also allow a relabeling of the points. \n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Constructing-the-FlipGraph","page":"FlipGraph","title":"Constructing the FlipGraph","text":"","category":"section"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"    flipgraph_modular","category":"page"},{"location":"flipGraph/#FlipGraphs.flipgraph_modular","page":"FlipGraph","title":"FlipGraphs.flipgraph_modular","text":"flipgraph_modular(g::Integer; kwargs..)\n\nConstruct the FlipGraph for the DeltaComplex D.  \n\nArguments\n\nfix_points::Bool=true : If is set to false, then the isomorphism also includes a renaming of the points. \n\n\n\n\n\nflipgraph_modular(D::DeltaComplex; kwargs..)\n\nConstruct the FlipGraph for the DeltaComplex D.  \n\nArguments\n\nfix_points::Bool=true : If is set to false, then the isomorphism also includes a renaming of the points. \ndepth::Integer = ∞ : Determines the depth to which the flip grap should be constructed. i.e. up to which distance from D. \n\n\n\n\n\n","category":"function"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"[1]: Hartke, S.G., & Radcliffe, A.J. (2008). McKay ’ s Canonical Graph Labeling Algorithm.","category":"page"},{"location":"generalUtilities/#General-utilities","page":"General utilities","title":"General utilities","text":"","category":"section"},{"location":"generalUtilities/","page":"General utilities","title":"General utilities","text":"These are some helping methods which youmight want to use, but aren't specific to one of the main structures in this package.","category":"page"},{"location":"generalUtilities/","page":"General utilities","title":"General utilities","text":"\ndiameter(::Matrix{<:Integer})\nadjacency_matrix(::Vector{Vector{T}}) where T<:Integer\ninvert_permutation(::Vector{<:Integer})\ndegrees(A::Matrix{<:Integer})","category":"page"},{"location":"generalUtilities/#Graphs.diameter-Tuple{Matrix{var\"#s1\"} where var\"#s1\"<:Integer}","page":"General utilities","title":"Graphs.diameter","text":"diameter(adjacency_matrix :: Matrix{<:Integer}) :: Int\n\nCompute the diameter of a graph from its simple adjacency matrix.\n\nAll values in adjacency_matrix should be either 0 or 1.\n\n\n\n\n\n","category":"method"},{"location":"generalUtilities/#FlipGraphs.adjacency_matrix-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T<:Integer","page":"General utilities","title":"FlipGraphs.adjacency_matrix","text":"adjacency_matrix(adjList::Vector{Vector{<:Integer}}) -> Matrix{Int}\n\nConstruct the adjacency matrix from an adjaceny list.\n\n\n\n\n\n","category":"method"},{"location":"generalUtilities/#FlipGraphs.invert_permutation-Tuple{Vector{var\"#s1\"} where var\"#s1\"<:Integer}","page":"General utilities","title":"FlipGraphs.invert_permutation","text":"invert_permutation(p::Vector{<:Integer})\n\nReturn the inverse of the permutation p. \n\nExample\n\njulia> p = [2,1,4,5,3];\njulia> p_inv = invert_perm(p); \njulia> show(p_inv)\n[4, 2, 5, 1, 6, 3]\njulia> show(p_inv[p])\n[1, 2, 3, 4, 5, 6]\n\n\n\n\n\n","category":"method"},{"location":"generalUtilities/#FlipGraphs.degrees-Tuple{Matrix{var\"#s1\"} where var\"#s1\"<:Integer}","page":"General utilities","title":"FlipGraphs.degrees","text":"degrees(A::Matrix{<:Integer}) -> Vector{<:Integer}\n\nReturn a vector containing the degrees of every vertex given an adjacency matrix A.\n\n\n\n\n\n","category":"method"},{"location":"#FlipGraphs.jl-Documentation","page":"FlipGraphs.jl Documentation","title":"FlipGraphs.jl Documentation","text":"","category":"section"},{"location":"","page":"FlipGraphs.jl Documentation","title":"FlipGraphs.jl Documentation","text":"Welcome to the documentation of the FlipGraphs package.  This package is part of my master's thesis on triangulations of closed surfaces.","category":"page"},{"location":"","page":"FlipGraphs.jl Documentation","title":"FlipGraphs.jl Documentation","text":"The aim of the package, is to model triangulations on any closed surface and to compute their respective flipgraphs.","category":"page"},{"location":"","page":"FlipGraphs.jl Documentation","title":"FlipGraphs.jl Documentation","text":"    FlipGraphs","category":"page"},{"location":"#FlipGraphs","page":"FlipGraphs.jl Documentation","title":"FlipGraphs","text":"FlipGraphs\n\nA package for triangulations of closed surfaces and their respective FlipGraphs.\n\n\n\n\n\n","category":"module"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"To install the package, you first need to install Julia.  After starting Julia, type the following:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using Pkg \njulia> Pkg.add(\"FlipGraphs\")","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"You can start using the package as follows:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using FlipGraphs\njulia> createDeltaComplex(4,10)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"You can get help for a function or structure by putting a question mark in front.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"help?> FlipGraph\n  struct FlipGraph <: AbstractGraph{Int}\n\n  A Graph representing the flipgraph of a Δ-Complex.\n\n  Vertices are different triangulations of the same surface.\n  Two vertices are linked by an edge, if the respective graphs differ only by a single flip.","category":"page"}]
}
