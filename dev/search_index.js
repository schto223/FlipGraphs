var documenterSearchIndex = {"docs":
[{"location":"holeyDeltaComplex/#HoleyDeltaComplex","page":"HoleyDeltaComplex","title":"HoleyDeltaComplex","text":"","category":"section"},{"location":"holeyDeltaComplex/","page":"HoleyDeltaComplex","title":"HoleyDeltaComplex","text":"The DeltaComplex structure is usefull for many applications. However, it has a slight issue that two different triangulations of the same surface, may result in the same DeltaComplex. In other words, a DeltaComplex misses some information about the underlying triangulation and can therefore not be used if one would, for example, like to construct the flipgraph (or rather a portion of latter) of the triangulations on a given surface.","category":"page"},{"location":"holeyDeltaComplex/","page":"HoleyDeltaComplex","title":"HoleyDeltaComplex","text":"The HoleyDeltaComplex structure solves this issue, by keeping track of the holes through which every single edge passes, and the orders thereof. This comes of course with a decrease in efficiency. It is therefore advised to use the simpler DeltaComplex if this bonus information is not needed. Another drawback is, that the HoleyDeltaComplex structure currently does not work for non-orientable surfaces.","category":"page"},{"location":"holeyDeltaComplex/#Structures","page":"HoleyDeltaComplex","title":"Structures","text":"","category":"section"},{"location":"holeyDeltaComplex/","page":"HoleyDeltaComplex","title":"HoleyDeltaComplex","text":"    HoleyDeltaComplex\n    Hole\n    Crossing","category":"page"},{"location":"holeyDeltaComplex/#FlipGraphs.HoleyDeltaComplex","page":"HoleyDeltaComplex","title":"FlipGraphs.HoleyDeltaComplex","text":"struct HoleyDeltaComplex\n\nAn extension of DeltaComplex, keeping track of which edges pass through which holes.\n\nMany operations become slower compared to a DeltaComplex.  However this structure is needed, if one wants to compare two different DeltaComplex'.\n\n\n\n\n\n","category":"type"},{"location":"holeyDeltaComplex/#FlipGraphs.Hole","page":"HoleyDeltaComplex","title":"FlipGraphs.Hole","text":"struct Hole\n\nA structure representing a hole/handle of an orientable surface.\n\nIt keeps track of the edges going in and out of the hole.\nAlthough edges are not directed, we give them an arbitrary direction in order to distinct them.\nThe Hole may be imagined as a line going anticlockwise around the inner surface of the hole.\nEdges, crossing this line from right to left are considered to be going into the hole, while edges crossing from left to right are coming out of the hole.\n\n\n\n\n\n","category":"type"},{"location":"holeyDeltaComplex/#FlipGraphs.Crossing","page":"HoleyDeltaComplex","title":"FlipGraphs.Crossing","text":"struct Crossing\n\nA structure representing an edge passing through a hole.\n\n\n\n\n\n","category":"type"},{"location":"holeyDeltaComplex/#Construction","page":"HoleyDeltaComplex","title":"Construction","text":"","category":"section"},{"location":"holeyDeltaComplex/","page":"HoleyDeltaComplex","title":"HoleyDeltaComplex","text":"    holey_delta_complex\n    subdivide!(::HoleyDeltaComplex, ::Integer)","category":"page"},{"location":"holeyDeltaComplex/#FlipGraphs.holey_delta_complex","page":"HoleyDeltaComplex","title":"FlipGraphs.holey_delta_complex","text":"holeyDeltaComplex(g::Integer, num_points::Integer = 1) -> HoleyDeltaComplex\n\nCreate a HoleyDeltaComplex of genus g.\n\n\n\n\n\n","category":"function"},{"location":"holeyDeltaComplex/#FlipGraphs.subdivide!-Tuple{HoleyDeltaComplex, Integer}","page":"HoleyDeltaComplex","title":"FlipGraphs.subdivide!","text":"subdivide!(HD ::HoleyDeltaComplex, t ::Integer)\n\nAdd a point to the inside of the t-th TriFace and connect it to each corner.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#Common-Graph-like-methods","page":"HoleyDeltaComplex","title":"Common Graph-like methods","text":"","category":"section"},{"location":"holeyDeltaComplex/","page":"HoleyDeltaComplex","title":"HoleyDeltaComplex","text":"As the HoleyDeltaComplex is essentially an extension of the DeltaComplex structure, all methods which take DeltaComplexes also work with HoleyDeltaComplexes.","category":"page"},{"location":"holeyDeltaComplex/","page":"HoleyDeltaComplex","title":"HoleyDeltaComplex","text":"    np(::HoleyDeltaComplex)\n    nv(::HoleyDeltaComplex)\n    ne(::HoleyDeltaComplex)\n\n    vertices(::HoleyDeltaComplex) \n    vertices(::HoleyDeltaComplex, ::DualEdge) \n    get_vertex(::HoleyDeltaComplex, ::Integer)\n\n    edges(::HoleyDeltaComplex)\n    edges(::HoleyDeltaComplex, ::Integer)\n    get_edge(::HoleyDeltaComplex, ::Integer)\n    get_edge(::HoleyDeltaComplex, ::Integer,::Integer)\n    edges_id(::HoleyDeltaComplex, ::Integer)\n\n    points(::HoleyDeltaComplex, ::DualEdge)\n","category":"page"},{"location":"holeyDeltaComplex/#FlipGraphs.np-Tuple{HoleyDeltaComplex}","page":"HoleyDeltaComplex","title":"FlipGraphs.np","text":"np(HD::HoleyDeltaComplex)\n\nReturn the number of points in the triangulation defined by HD.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#Graphs.nv-Tuple{HoleyDeltaComplex}","page":"HoleyDeltaComplex","title":"Graphs.nv","text":"nv(HD::HoleyDeltaComplex)\n\nReturn the number of vertices(i.e. triangular faces) in HD.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#Graphs.ne-Tuple{HoleyDeltaComplex}","page":"HoleyDeltaComplex","title":"Graphs.ne","text":"ne(HD::HoleyDeltaComplex)\n\nReturn the number of edges in the DeltaComplex HD.\n\nThis is equal to the number of edges in the triangulation itself.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#Graphs.vertices-Tuple{HoleyDeltaComplex}","page":"HoleyDeltaComplex","title":"Graphs.vertices","text":"vertices(HD::HoleyDeltaComplex) -> Vector{TriFace}\n\nReturn the list of all vertices in HD.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#Graphs.vertices-Tuple{HoleyDeltaComplex, DualEdge}","page":"HoleyDeltaComplex","title":"Graphs.vertices","text":"vertices(HD::HoleyDeltaComplex, d::DualEdge) -> Tuple{TriFace, TriFace}\n\nReturn both vertices adjacent to d.\n\nThe first TriFace is on the left of the edge, and the second one on the right of the edge.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.get_vertex-Tuple{HoleyDeltaComplex, Integer}","page":"HoleyDeltaComplex","title":"FlipGraphs.get_vertex","text":"get_vertex(HD::HoleyDeltaComplex, t::Integer) -> TriFace\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#Graphs.edges-Tuple{HoleyDeltaComplex}","page":"HoleyDeltaComplex","title":"Graphs.edges","text":"edges(HD::HoleyDeltaComplex) -> Vector{DualEdge}\n\nReturn the list of all edges in HD. \n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#Graphs.edges-Tuple{HoleyDeltaComplex, Integer}","page":"HoleyDeltaComplex","title":"Graphs.edges","text":"edges(HD::HoleyDeltaComplex, t::Integer) -> Vector{DualEdge}\n\nReturn the list of all 3 edges that are incident to the t-th Triface in HD. \n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.get_edge-Tuple{HoleyDeltaComplex, Integer}","page":"HoleyDeltaComplex","title":"FlipGraphs.get_edge","text":"get_edge(HD::HoleyDeltaComplex, e::Integer) -> DualEdge\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.get_edge-Tuple{HoleyDeltaComplex, Integer, Integer}","page":"HoleyDeltaComplex","title":"FlipGraphs.get_edge","text":"get_edge(HD::HoleyDeltaComplex, t::Integer, side::Integer) -> DualEdge\n\nReturn the edge that forms the respective side in the given triangle t.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.edges_id-Tuple{HoleyDeltaComplex, Integer}","page":"HoleyDeltaComplex","title":"FlipGraphs.edges_id","text":"edges_id(HD::HoleyDeltaComplex, t::Integer) -> Tuple{Int, Int, Int}\n\nReturn the indices of all 3 edges that are incident to the t-th vertex. \n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.points-Tuple{HoleyDeltaComplex, DualEdge}","page":"HoleyDeltaComplex","title":"FlipGraphs.points","text":"points(HD::HoleyDeltaComplex, d::DualEdge) -> Tuple{Int, Int}\n\nReturn both endpoints of d in the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/","page":"HoleyDeltaComplex","title":"HoleyDeltaComplex","text":"    rename_edges!(::HoleyDeltaComplex, ::Vector{<:Integer})\n    rename_points!(::HoleyDeltaComplex, ::Vector{<:Integer})\n    rename_vertices!(::HoleyDeltaComplex, ::Vector{<:Integer})","category":"page"},{"location":"holeyDeltaComplex/#FlipGraphs.rename_edges!-Tuple{HoleyDeltaComplex, Vector{var\"#s2\"} where var\"#s2\"<:Integer}","page":"HoleyDeltaComplex","title":"FlipGraphs.rename_edges!","text":"rename_edges!(HD::HoleyDeltaComplex, p::Vector{<:Integer})\n\nRename every vertex(TriFace) in HD, according to the permutation p.\n\nTriFace 1 => TriFace p[1]\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.rename_points!-Tuple{HoleyDeltaComplex, Vector{var\"#s2\"} where var\"#s2\"<:Integer}","page":"HoleyDeltaComplex","title":"FlipGraphs.rename_points!","text":"rename_points!(HD::HoleyDeltaComplex, p::Vector{<:Integer})\n\nRename all the points in D according to the permutation p.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.rename_vertices!-Tuple{HoleyDeltaComplex, Vector{var\"#s2\"} where var\"#s2\"<:Integer}","page":"HoleyDeltaComplex","title":"FlipGraphs.rename_vertices!","text":"rename_vertices!(HD::HoleyDeltaComplex, p::Vector{<:Integer})\n\nRename every vertex(TriFace) in D, according to the permutation p.\n\nTriFace 1 => TriFace p[1]\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#Classifying-the-triangulation","page":"HoleyDeltaComplex","title":"Classifying the triangulation","text":"","category":"section"},{"location":"holeyDeltaComplex/","page":"HoleyDeltaComplex","title":"HoleyDeltaComplex","text":"    euler_characteristic(::HoleyDeltaComplex)\n    genus(::HoleyDeltaComplex)\n    diameter_triangulation(::HoleyDeltaComplex)\n    diameter_deltaComplex(::HoleyDeltaComplex)\n    adjacency_matrix_deltaComplex(::HoleyDeltaComplex)\n    adjacency_matrix_triangulation(::HoleyDeltaComplex)\n    multi_adjacency_matrix_triangulation(::HoleyDeltaComplex)\n    point_degrees(::HoleyDeltaComplex)\n    relative_point_degrees(::HoleyDeltaComplex, ::Vector{<:Integer}, ::Vector{<:Integer})","category":"page"},{"location":"holeyDeltaComplex/#FlipGraphs.euler_characteristic-Tuple{HoleyDeltaComplex}","page":"HoleyDeltaComplex","title":"FlipGraphs.euler_characteristic","text":"euler_characteristic(HD::HoleyDeltaComplex) -> Int\n\nCompute the euler characteristic of the HoleyDeltaComplex HD:\nX = vertices - edges + faces\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.genus-Tuple{HoleyDeltaComplex}","page":"HoleyDeltaComplex","title":"FlipGraphs.genus","text":"genus(HD::HoleyDeltaComplex) -> Int\n\nCompute the genus of the HoleyDeltaComplex HD.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.diameter_triangulation-Tuple{HoleyDeltaComplex}","page":"HoleyDeltaComplex","title":"FlipGraphs.diameter_triangulation","text":"diameter_triangulation(HD::HoleyDeltaComplex) -> Int\n\nCompute the diameter of the triangulation defined by the HoleyDeltaComplex HD.\n The diameter of a Graph is the greatest minimal distance between any 2 vertices.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.diameter_deltaComplex-Tuple{HoleyDeltaComplex}","page":"HoleyDeltaComplex","title":"FlipGraphs.diameter_deltaComplex","text":"diameter_deltaComplex(HD::HoleyDeltaComplex)\n\nCompute the diameter of the HoleyDeltaComplex HD.\n\nThe diameter of a Graph is the greatest minimal distance between any 2 vertices.\n\nSee also diameter_triangulation\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.adjacency_matrix_deltaComplex-Tuple{HoleyDeltaComplex}","page":"HoleyDeltaComplex","title":"FlipGraphs.adjacency_matrix_deltaComplex","text":"adjacency_matrix_deltaComplex(HD::HoleyDeltaComplex) :: Matrix{Int}\n\nCompute the adjacency matrix of the delta complex HD.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.adjacency_matrix_triangulation-Tuple{HoleyDeltaComplex}","page":"HoleyDeltaComplex","title":"FlipGraphs.adjacency_matrix_triangulation","text":"adjacency_matrix_triangulation(HD::HoleyDeltaComplex) :: Matrix{Int}\n\nCompute the simple adjacency matrix of the triangulation defined by HD.\n\nAll entries are either 0 or 1.\n\nSee also multi_adjacency_matrix_triangulation\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.multi_adjacency_matrix_triangulation-Tuple{HoleyDeltaComplex}","page":"HoleyDeltaComplex","title":"FlipGraphs.multi_adjacency_matrix_triangulation","text":"multi_adjacency_matrix_triangulation(HD::HoleyDeltaComplex) :: Matrix{Int}\n\nCompute the adjacency matrix of the multigraph of the triangulation defined by HD.\n\nThe ij-th entry not only notes if both points are connected,  but also the number of edges that connect these two points.\n\nSee also adjacency_matrix_triangulation\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.point_degrees-Tuple{HoleyDeltaComplex}","page":"HoleyDeltaComplex","title":"FlipGraphs.point_degrees","text":"point_degrees(HD::HoleyDeltaComplex) -> Vector{Int}\n\nReturn a vector containing the respective degree of each point in the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.relative_point_degrees-Tuple{HoleyDeltaComplex, Vector{var\"#s2\"} where var\"#s2\"<:Integer, Vector{var\"#s1\"} where var\"#s1\"<:Integer}","page":"HoleyDeltaComplex","title":"FlipGraphs.relative_point_degrees","text":"relative_point_degrees(HD::HoleyDeltaComplex, U::Vector{<:Integer}, V::Vector{<:Integer})\n\nReturn a vector containing the degree to V for each point in U.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#Flipping","page":"HoleyDeltaComplex","title":"Flipping","text":"","category":"section"},{"location":"holeyDeltaComplex/","page":"HoleyDeltaComplex","title":"HoleyDeltaComplex","text":"    flip(::HoleyDeltaComplex, ::Integer)\n    flip(::HoleyDeltaComplex, ::DualEdge)\n    flip!(::HoleyDeltaComplex, ::Integer)\n    flip!(::HoleyDeltaComplex, ::DualEdge)\n    is_flippable(::HoleyDeltaComplex, ::Integer)\n    random_flips!(::HoleyDeltaComplex, ::Integer)","category":"page"},{"location":"holeyDeltaComplex/#FlipGraphs.flip-Tuple{HoleyDeltaComplex, Integer}","page":"HoleyDeltaComplex","title":"FlipGraphs.flip","text":"flip(HD::HoleyDeltaComplex, e::Integer)\n\nReturn a copy of HD where the e-th edge has been flipped.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.flip-Tuple{HoleyDeltaComplex, DualEdge}","page":"HoleyDeltaComplex","title":"FlipGraphs.flip","text":"flip(HD::HoleyDeltaComplex, d::DualEdge)\n\nReturn a copy of HD where the edge d has been flipped.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.flip!-Tuple{HoleyDeltaComplex, Integer}","page":"HoleyDeltaComplex","title":"FlipGraphs.flip!","text":"flip!(HD::HoleyDeltaComplex, e::Integer)\n\nFlip, if possible, the given edge in HD.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.flip!-Tuple{HoleyDeltaComplex, DualEdge}","page":"HoleyDeltaComplex","title":"FlipGraphs.flip!","text":"flip!(HD::HoleyDeltaComplex, d::DualEdge)\n\nFlip, if possible, the given edge in HD.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.is_flippable-Tuple{HoleyDeltaComplex, Integer}","page":"HoleyDeltaComplex","title":"FlipGraphs.is_flippable","text":"is_flippable(HD::HoleyDeltaComplex, e::Integer) -> Bool\n\nReturn true if the e-th edge can be flipped.\n\nThis is always the case if the edge does not connect a TriFace to itself.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.random_flips!-Tuple{HoleyDeltaComplex, Integer}","page":"HoleyDeltaComplex","title":"FlipGraphs.random_flips!","text":"random_flips!(HD::HoleyDeltaComplex, n::Integer)\n\nRandomly pick an edge, and flip it if possible. Repeat this n times.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#HoleyDeltaComplex-only","page":"HoleyDeltaComplex","title":"HoleyDeltaComplex only","text":"","category":"section"},{"location":"holeyDeltaComplex/","page":"HoleyDeltaComplex","title":"HoleyDeltaComplex","text":"    num_crossings(::Hole)\n    edge_crossings(::HoleyDeltaComplex, ::Integer)\n    get_crossing(::Hole)\n    remove_holeloops!(::HoleyDeltaComplex)","category":"page"},{"location":"holeyDeltaComplex/#FlipGraphs.num_crossings-Tuple{Hole}","page":"HoleyDeltaComplex","title":"FlipGraphs.num_crossings","text":"num_crossings(H::Hole)\n\nReturn the number of Crossing that occur at H.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.edge_crossings-Tuple{HoleyDeltaComplex, Integer}","page":"HoleyDeltaComplex","title":"FlipGraphs.edge_crossings","text":"edge_crossings(HD::HoleyDeltaComplex, e::Integer) -> Vector{Crossing}\n\nReturn an array of all the Crossings involving the e-th edge.\n\nThe Crossings are ordered along the direction of e.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.get_crossing-Tuple{Hole}","page":"HoleyDeltaComplex","title":"FlipGraphs.get_crossing","text":"get_crossing(H::Hole) -> Crossing\n\nReturn any Crossing of the hole H.\n\nUsually the Crossing which is returned, was the last one added to the Hole.\n\n\n\n\n\n","category":"method"},{"location":"holeyDeltaComplex/#FlipGraphs.remove_holeloops!-Tuple{HoleyDeltaComplex}","page":"HoleyDeltaComplex","title":"FlipGraphs.remove_holeloops!","text":"remove_holeloops!(HD::HoleyDeltaComplex)\n\nRemove all pairs of crossings where an edge enters a hole, and imeadiately comes out again.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Triangulations-of-Convex-Polygons","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"","category":"section"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"In order to better understand triangulations, flips and flipgraphs, it can be helpfull to start simple. If you take any number of points, and iteratively connect them with staight edges that do not cross each other,  until you can no longer add an edge that does not cross any other edge, what you'll get is a triangulation.","category":"page"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"To get from one triangulation of these points to another, you may choose an inner edge, and flip it.  If you look at any inner edge, the two triangles adjacent to it form a quadrilateral with the edge as one of its diagonals. By flipping an edge, all we have to do is replace it by the other diagonal. As we don't want to have straight edges that cross each other, a flip can only be done, if the quadrilateral is convex, and no three of its corners lie on the same line. As we are interested in taking this theory to closed surfaces, where we will no longer restrict the edges to being straight, we will only consider triangulations of points in convex general position. In this case, a triangulation in the geometric sense is equivalent to a triangulation in the graph sense.","category":"page"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"In graph theory, we do not care, if edges are straight or curved. In this case, a triangulation is simply a maximal(in regards to the number of edges) planar graph with a fixed number of points. Here, we do not care where the points are located, however, in order keep in line with the geometric sense and have a simple visualization,we will consider these points to be the vertices of a convex polygon (i.e. points in convex position). ","category":"page"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"    TriangulatedPolygon","category":"page"},{"location":"polygonTriangulation/#FlipGraphs.TriangulatedPolygon","page":"Triangulations of Convex Polygons","title":"FlipGraphs.TriangulatedPolygon","text":"struct TriangulatedPolygon <: AbstractGraph{Integer}\n\nA structure representing a triangulation of a convex polygon.\n\n\n\n\n\n","category":"type"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"TriangulatedPolygon implements the AbstractGraph interface from Graphs.jl. It is therefore possible to use it with other packages that work with Graphs.jl. This is very helpfull for plotting the graph.\\\n Vertices are not explicity stored in TriangulatedPolygon. Only the total number of vertices is stored. They are implicitely labeled by the integers from 1 up to the total number of vertices.","category":"page"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"Edges are stored as an adjacency list of which vertices are connected to another.","category":"page"},{"location":"polygonTriangulation/#Constructors","page":"Triangulations of Convex Polygons","title":"Constructors","text":"","category":"section"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"    triangulated_polygon","category":"page"},{"location":"polygonTriangulation/#FlipGraphs.triangulated_polygon","page":"Triangulations of Convex Polygons","title":"FlipGraphs.triangulated_polygon","text":"triangulated_polygon(n::Integer) -> TriangulatedPolygon\n\nCreate a triangulated convex n-gon. \n\nVertices are named from 1 to n in an anticlockwise manner. The inside is triangulated in a zig-zag manner.\n\n\n\n\n\n","category":"function"},{"location":"polygonTriangulation/#Graph-Methods","page":"Triangulations of Convex Polygons","title":"Graph Methods","text":"","category":"section"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"    nv(::TriangulatedPolygon)\n    ne(::TriangulatedPolygon)\n    vertices(::TriangulatedPolygon)\n    edges(::TriangulatedPolygon)\n    has_vertex(::TriangulatedPolygon, v)\n    has_edge(::TriangulatedPolygon, e::Edge)\n    has_edge(::TriangulatedPolygon, s, d)\n    neighbors(::TriangulatedPolygon, ::Integer)\n    degrees(::TriangulatedPolygon)\n    is_isomorph(::TriangulatedPolygon, ::TriangulatedPolygon, ::Vector{Vector{Integer}})\n    rename_vertices(::TriangulatedPolygon, ::Vector{Integer})\n    adjacency_matrix(::TriangulatedPolygon)","category":"page"},{"location":"polygonTriangulation/#Graphs.nv-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"Graphs.nv","text":"nv(g::TriangulatedPolygon)\n\nReturn the number of vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.ne-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"Graphs.ne","text":"ne(g::TriangulatedPolygon)\n\nReturn the number of edges in g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.vertices-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"Graphs.vertices","text":"vertices(g::TriangulatedPolygon)\n\nReturn a list of all the vertices in g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.edges-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"Graphs.edges","text":"edges(g::TriangulatedPolygon) -> Vector{Edges}\n\nCompute and return a list of all the edges in g.\n\nEdges are not directed. It is however necessary to define a source and a target.  For TriangulatedPolygon, the source will be the incident vertex with the smaller id.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.has_vertex-Tuple{TriangulatedPolygon, Any}","page":"Triangulations of Convex Polygons","title":"Graphs.has_vertex","text":"ne(g::TriangulatedPolygon)\n\nReturn the number of edges in g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.has_edge-Tuple{TriangulatedPolygon, Graphs.SimpleGraphs.SimpleEdge}","page":"Triangulations of Convex Polygons","title":"Graphs.has_edge","text":"has_edge(g::TriangulatedPolygon, e::Edge)\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.has_edge-Tuple{TriangulatedPolygon, Any, Any}","page":"Triangulations of Convex Polygons","title":"Graphs.has_edge","text":"has_edge(g::TriangulatedPolygon, s, d)\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Graphs.neighbors-Tuple{TriangulatedPolygon, Integer}","page":"Triangulations of Convex Polygons","title":"Graphs.neighbors","text":"neighbors(g::TriangulatedPolygon, v::Integer)\n\nReturn a list of all the vertices in g that are adjacent to v.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.degrees-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.degrees","text":"degrees(g::TriangulatedPolygon) -> Vector{Int}\n\nReturn a list of the degrees of every single vertex in g\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.is_isomorph-Tuple{TriangulatedPolygon, TriangulatedPolygon, Vector{Vector{Integer}}}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.is_isomorph","text":"is_isomorph(g1::TriangulatedPolygon, g2::TriangulatedPolygon, permutations::Vector{Vector{Integer}})\n\nReturn true if g1 is identical to g2 up to a renaming of the vertices of g1 by one of the given permutations.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.rename_vertices-Tuple{TriangulatedPolygon, Vector{Integer}}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.rename_vertices","text":"rename_vertices(g::TriangulatedPolygon, p::Vector{<:Integer})\n\nRename the vertices of g by applying the permutation p.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.adjacency_matrix-Tuple{TriangulatedPolygon}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.adjacency_matrix","text":"adjacency_matrix(g::TriangulatedPolygon)\n\nCompute the adjacency matrix for the triangulated graph g. \n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#Flipping","page":"Triangulations of Convex Polygons","title":"Flipping","text":"","category":"section"},{"location":"polygonTriangulation/","page":"Triangulations of Convex Polygons","title":"Triangulations of Convex Polygons","text":"    is_flippable(::TriangulatedPolygon, ::Integer, ::Integer)\n    is_flippable(::TriangulatedPolygon, ::Edge)\n    flip!(::TriangulatedPolygon, ::Integer, ::Integer)\n    flip!(::TriangulatedPolygon, ::Edge)\n    flip(::TriangulatedPolygon, ::Edge)","category":"page"},{"location":"polygonTriangulation/#FlipGraphs.is_flippable-Tuple{TriangulatedPolygon, Integer, Integer}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.is_flippable","text":"is_flippable(g::TriangulatedPolygon, src::Integer, dst::Integer) -> Bool\n\nReturn whether or not the edge can be flipped.\n\nNote that for a triangulation of a convex polygon inner edges are always flippable, while outer edges cannot be flipped.    \n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.is_flippable-Tuple{TriangulatedPolygon, Graphs.SimpleGraphs.SimpleEdge}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.is_flippable","text":"is_flippable(g::TriangulatedPolygon, e::Edge) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.flip!-Tuple{TriangulatedPolygon, Integer, Integer}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.flip!","text":"flip!(g::TriangulatedPolygon, src::Integer, dst::Integer)\n\nFlip the the edge incident to src and dst in g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.flip!-Tuple{TriangulatedPolygon, Graphs.SimpleGraphs.SimpleEdge}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.flip!","text":"flip!(g::TriangulatedPolygon, e::Edge)\n\nFlip e in g.\n\n\n\n\n\n","category":"method"},{"location":"polygonTriangulation/#FlipGraphs.flip-Tuple{TriangulatedPolygon, Graphs.SimpleGraphs.SimpleEdge}","page":"Triangulations of Convex Polygons","title":"FlipGraphs.flip","text":"flip(g::TriangulatedPolygon, e::Edge)\n\nReturn the triangulated polygon obtained by flipping the edge e in g.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#DeltaComplexes","page":"DeltaComplexes","title":"DeltaComplexes","text":"","category":"section"},{"location":"deltaComplex/#Modelling-a-triangulation-on-a-closed-surface","page":"DeltaComplexes","title":"Modelling a triangulation on a closed surface","text":"","category":"section"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"A Δ-complex is a representation of a triangulation on a closed surface. To define a triangulation on a closed surface, it does not suffice to take into account vertices and edges. We will also need to take into account the triangular faces between them. Therefore the triangulations are modeled using an extension of their dual graph.","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"Vertices are triangular faces which in turn consist of three points, and three edges. These points and edges are not necessarily distinct. Edges in the dual Graph(i.e. the Δ-complex) connect two triangular faces if they in turn share an edge. In order to avoid confusion between the edges of the triangulation and the edges in the dual graph, I will, hence forwards call the latter dual edge.","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    DeltaComplex\n    DualEdge\n    TriFace","category":"page"},{"location":"deltaComplex/#FlipGraphs.DeltaComplex","page":"DeltaComplexes","title":"FlipGraphs.DeltaComplex","text":"struct DeltaComplex\n\nA Graph datastructure representing a triangulation of a surface.\n\nThe DeltaComplex may be thought of as the dual of a triangulation.\n\nVertices are triangular faces (TriFace). Every vertex has three edges (DualEdge) incident to it.\n\n\n\n\n\n","category":"type"},{"location":"deltaComplex/#FlipGraphs.DualEdge","page":"DeltaComplexes","title":"FlipGraphs.DualEdge","text":"struct DualEdge\n\nRepresentation of an edge in a DeltaComplex (i.e. the dual graph of a triangulation).\n\nA DualEdge connects two TriFaces through specific sides.\n\n\n\n\n\n","category":"type"},{"location":"deltaComplex/#FlipGraphs.TriFace","page":"DeltaComplexes","title":"FlipGraphs.TriFace","text":"struct TriFace\n\nA TriFace represents a triangle in the triangulization of a surface. \n\nThe TriFace's form the vertices of a DeltaComplex. Each TriFace is formed between 3 points and is connected to 3 Trifaces through DualEdges. The points and neighboring triangles do not have to be unique.\n\nThe points and edges are stored in an anticlockwise order.\nThe first edge/side is between the first and second point.\nThe second edge/side is between the second and third point.\nThe third edge/side is between the third and first point.\n\n\n\n\n\n\n","category":"type"},{"location":"deltaComplex/#Construction-of-a-DeltaComplex","page":"DeltaComplexes","title":"Construction of a DeltaComplex","text":"","category":"section"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"This Module comes with some handy and easy to use tools to construct a triangulation of a surface:","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    delta_complex\n    subdivide!(::DeltaComplex, ::Integer)","category":"page"},{"location":"deltaComplex/#FlipGraphs.delta_complex","page":"DeltaComplexes","title":"FlipGraphs.delta_complex","text":"delta_complex(genus , num_points = 1)\n\nCreate a triangulation of an orientable surface with num_points points on it. \n\nBy default num_points is set to 1.\n\n\n\n\n\ndelta_complex(s :: Array{<:Integer,1})\n\nCreate a triangulation of an orientable surface with a single point, by gluing corresponding edges together.\n s should be an array of nonzero integers representing the edges of a polygon in anticlockwise order.\\  The i-th edge is orientated anticlockwise if s[i]>0 and anticlockwise if s[i]<0.\nIf s[i] and s[j] have the same absolute value, they are glued together while respecting their orientation.\n #Examples The following results in the triangulation of a torus with one point:\n\njulia> delta_complex([1,2,-1,-2])\n\nThe following results in the triangulation of a Klein bottle with one point:\n\njulia> delta_complex([1,2,-1,-2])\n\n\n\n\n\n","category":"function"},{"location":"deltaComplex/#FlipGraphs.subdivide!-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"FlipGraphs.subdivide!","text":"subdivide!(D::DeltaComplex, t::Integer)\n\nAdd a point to the inside of the t-th TriFace and connect it to each corner.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Common-Graph-like-methods","page":"DeltaComplexes","title":"Common Graph-like methods","text":"","category":"section"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"DeltaComplex is not an implementation of Graphs.AbstractGraph. However, as it is similar to a simple graph, I used the same notation and function names for simplicity","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    np(::DeltaComplex)\n    nv(::DeltaComplex)\n    ne(::DeltaComplex)\n    vertices(::DeltaComplex)\n    get_vertex(::DeltaComplex, ::Integer)\n    get_vertex_id(::DualEdge, ::Integer)\n    edges(::DeltaComplex)\n    get_edge(::DeltaComplex, ::Integer)\n    get_edge(::DeltaComplex, ::Integer, ::Integer)\n    id(::DualEdge)\n\n    points(::TriFace)\n    get_point(::TriFace, ::Integer)\n    points(::DeltaComplex, ::DualEdge)\n\n    vertices(::DeltaComplex, ::DualEdge)\n    vertices_id(::DualEdge)\n\n    get_edge(::TriFace, ::Integer) \n    get_edge_id(::TriFace, ::Integer)\n    edges(::TriFace)\n    edges(::DeltaComplex, ::Integer)\n    edges_id(::DeltaComplex, ::Integer) \n    id(::TriFace) \n\n    other_endpoint(::DualEdge, ::Integer, ::Integer)\n    is_similar(::DualEdge, ::DualEdge)","category":"page"},{"location":"deltaComplex/#FlipGraphs.np-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.np","text":"np(D::DeltaComplex)\n\nReturn the number of points in the triangulation defined by D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.nv-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"Graphs.nv","text":"nv(D::DeltaComplex)\n\nReturn the number of vertices(i.e. triangular faces) in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.ne-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"Graphs.ne","text":"ne(D::DeltaComplex)\n\nReturn the number of edges in the DeltaComplex D.\n\nThis is equal to the number of edges in the triangulation itself.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.vertices-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"Graphs.vertices","text":"vertices(D::DeltaComplex) -> Vector{TriFace}\n\nReturn the list of all vertices in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_vertex-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"FlipGraphs.get_vertex","text":"get_vertex(D::DeltaComplex, t::Integer) -> TriFace\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_vertex_id-Tuple{DualEdge, Integer}","page":"DeltaComplexes","title":"FlipGraphs.get_vertex_id","text":"get_vertex_id(d::DualEdge, side::Integer) -> Int\n\nReturn the index of the vertex (TriFace) to the left ofd`.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.edges-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"Graphs.edges","text":"edges(D::DeltaComplex) -> Vector{DualEdge}\n\nReturn the list of all the DualEdges in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_edge-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"FlipGraphs.get_edge","text":"get_edge(D::DeltaComplex, e::Integer) -> DualEdge\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_edge-Tuple{DeltaComplex, Integer, Integer}","page":"DeltaComplexes","title":"FlipGraphs.get_edge","text":"get_edge(D::DeltaComplex, t::Integer, side::Integer) -> DualEdge\n\nReturn the edge that forms the respective side in the given triangle t.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.id-Tuple{DualEdge}","page":"DeltaComplexes","title":"FlipGraphs.id","text":"id(d::DualEdge) -> Int\n\nReturn the index of d in its DeltaComplex.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.points-Tuple{TriFace}","page":"DeltaComplexes","title":"FlipGraphs.points","text":"points(T::TriFace) -> Tuple{Int, Int, Int}\n\nReturn a tuple of the three points, that form the corners of T.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_point-Tuple{TriFace, Integer}","page":"DeltaComplexes","title":"FlipGraphs.get_point","text":"get_point(T::TriFace, corner::Integer) -> Int\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.points-Tuple{DeltaComplex, DualEdge}","page":"DeltaComplexes","title":"FlipGraphs.points","text":"points(D::DeltaComplex, d::DualEdge) -> Tuple{Int, Int}\n\nReturn both endpoints of d in the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.vertices-Tuple{DeltaComplex, DualEdge}","page":"DeltaComplexes","title":"Graphs.vertices","text":"vertices(D::DeltaComplex, d::DualEdge) -> Tuple{TriFace, TriFace}\n\nReturn both vertices adjacent to d.\n\nThe first TriFace is on the left of the edge, and the second one on the right of the edge.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.vertices_id-Tuple{DualEdge}","page":"DeltaComplexes","title":"FlipGraphs.vertices_id","text":"vertices_id(d::DualEdge) -> Tuple{Int, Int}\n\nReturn the indices of both vertices (TriFaces) adjacent to d.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_edge-Tuple{TriFace, Integer}","page":"DeltaComplexes","title":"FlipGraphs.get_edge","text":"get_edge(T::TriFace, side::Integer) -> DualEdge\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.get_edge_id-Tuple{TriFace, Integer}","page":"DeltaComplexes","title":"FlipGraphs.get_edge_id","text":"get_edge_id(T::TriFace, side::Integer) -> Integer\n\nReturn the index of the edge on the respective side in T.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.edges-Tuple{TriFace}","page":"DeltaComplexes","title":"Graphs.edges","text":"edges(T::TriFace) -> Vector{DualEdge}\n\nReturn the list of all 3 edges that are incident to T. \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Graphs.edges-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"Graphs.edges","text":"edges(D::DeltaComplex, t::Integer) -> Vector{DualEdge}\n\nReturn the list of all 3 edges that are incident to the t-th Triface in D. \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.edges_id-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"FlipGraphs.edges_id","text":"edges_id(T::TriFace) -> Tuple{Int, Int, Int}\n\nReturn the indices of all 3 edges that are incident to T. \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.id-Tuple{TriFace}","page":"DeltaComplexes","title":"FlipGraphs.id","text":"id(T::TriFace)\n\nReturn the index of T in its DeltaComplex. \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.other_endpoint-Tuple{DualEdge, Integer, Integer}","page":"DeltaComplexes","title":"FlipGraphs.other_endpoint","text":"other_endpoint(d::DualEdge, t::Integer, side::Integer) -> Tuple{Int, Int8}\n\nReturn the index of the other TriFace and its respective side, that is incident to d \n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.is_similar-Tuple{DualEdge, DualEdge}","page":"DeltaComplexes","title":"FlipGraphs.is_similar","text":"is_similar(d1::DualEdge, d2::DualEdge) -> Bool\n\nReturn true if d1 and d2 have the same twist and are connected to the same triangles.\n\nThis is only the case if d1 and d2 are the same edge, or if they are incident to a point of degree 2.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Classifying-the-triangulation","page":"DeltaComplexes","title":"Classifying the triangulation","text":"","category":"section"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"Here are some usefull methods, to pull out general information about the Δ-Complex, and the triangulation it represents:","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    euler_characteristic(::DeltaComplex)\n    genus(::DeltaComplex)\n    diameter_triangulation(::DeltaComplex)\n    diameter_deltaComplex(::DeltaComplex)\n    adjacency_matrix_deltaComplex(::DeltaComplex)\n    adjacency_matrix_triangulation(::DeltaComplex)\n    multi_adjacency_matrix_triangulation(::DeltaComplex)","category":"page"},{"location":"deltaComplex/#FlipGraphs.euler_characteristic-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.euler_characteristic","text":"euler_characteristic(D::DeltaComplex)\n\nCompute the euler characteristic of the DeltaComplex D:\nX = vertices - edges + faces\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.genus-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.genus","text":"genus(D::DeltaComplex)\n\nCompute the genus of the DeltaComplex D if it forms an orientable surface.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.diameter_triangulation-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.diameter_triangulation","text":"diameter_triangulation(D::DeltaComplex)\n\nCompute the diameter of the triangulation defined by the DeltaComplex D.\n\nThe diameter of a Graph is the greatest minimal distance between any 2 vertices.\n\nSee also diameter_deltaComplex\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.diameter_deltaComplex-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.diameter_deltaComplex","text":"diameter_deltaComplex(D::DeltaComplex)\n\nCompute the diameter of the DeltaComplex D.\n The diameter of a Graph is the greatest minimal distance between any 2 vertices.\n\nSee also diameter_triangulation\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.adjacency_matrix_deltaComplex-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.adjacency_matrix_deltaComplex","text":"adjacency_matrix_deltaComplex(D::DeltaComplex) :: Matrix{<:Integer}\n\nCompute the adjacency matrix of the delta complex D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.adjacency_matrix_triangulation-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.adjacency_matrix_triangulation","text":"adjacency_matrix_triangulation(D::DeltaComplex) :: Matrix{Int}\n\nCompute the simple adjacency matrix of the triangulation defined by D.\n\nAll entries are either 0 or 1.\n\nSee also multi_adjacency_matrix_triangulation\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.multi_adjacency_matrix_triangulation-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.multi_adjacency_matrix_triangulation","text":"multi_adjacency_matrix_triangulation(D::DeltaComplex) :: Matrix{Int}\n\nCompute the adjacency matrix of the multigraph of the triangulation defined by D.\n\nThe i,j-th entry not only notes if both points are connected,  but also the number of edges that connect these two points.\n\nSee also adjacency_matrix_triangulation\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    point_degrees(::DeltaComplex)\n    relative_point_degrees(::DeltaComplex, ::Vector{<:Integer}, ::Vector{<:Integer})","category":"page"},{"location":"deltaComplex/#FlipGraphs.point_degrees-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.point_degrees","text":"point_degrees(D::DeltaComplex) -> Vector{<:Integer}\n\nReturn a vector containing the respective degree of each point in the triangulation.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.relative_point_degrees-Tuple{DeltaComplex, Vector{var\"#s1\"} where var\"#s1\"<:Integer, Vector{var\"#s2\"} where var\"#s2\"<:Integer}","page":"DeltaComplexes","title":"FlipGraphs.relative_point_degrees","text":"relative_point_degrees(D::DeltaComplex, U::Vector{<:Integer}, V::Vector{<:Integer})\n\nReturn a vector containing the degree to V for each point in U.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    rename_edges!(::DeltaComplex, ::Vector{<:Integer})\n    rename_points!(D::DeltaComplex, p::Vector{<:Integer})\n    rename_vertices!(::DeltaComplex, ::Vector{<:Integer})","category":"page"},{"location":"deltaComplex/#FlipGraphs.rename_edges!-Tuple{DeltaComplex, Vector{var\"#s2\"} where var\"#s2\"<:Integer}","page":"DeltaComplexes","title":"FlipGraphs.rename_edges!","text":"rename_edges!(D::DeltaComplex, p::Vector{<:Integer})\n\nRename every vertex(TriFace) in D, according to the permutation p.\n\nTriFace 1 => TriFace p[1]\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.rename_points!-Tuple{DeltaComplex, Vector{var\"#s2\"} where var\"#s2\"<:Integer}","page":"DeltaComplexes","title":"FlipGraphs.rename_points!","text":"rename_points!(D::DeltaComplex, p::Vector{<:Integer})\n\nRename all the points in D according to the permutation p.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.rename_vertices!-Tuple{DeltaComplex, Vector{var\"#s2\"} where var\"#s2\"<:Integer}","page":"DeltaComplexes","title":"FlipGraphs.rename_vertices!","text":"rename_vertices!(D::DeltaComplex, p::Vector{<:Integer})\n\nRename every vertex(TriFace) in D, according to the permutation p.\n\nTriFace 1 => TriFace p[1]\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#Non-orientable-closed-surfaces","page":"DeltaComplexes","title":"Non-orientable closed surfaces","text":"","category":"section"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"Regarding on which way edges are glued together, the resulting surface may be non-orientable. These surfaces can also be modeled by DeltaComplex and all of the methods above (with the exception of genus) may still be applied.","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    is_orientable(::DeltaComplex)\n    demigenus\n    twist_edges!","category":"page"},{"location":"deltaComplex/#FlipGraphs.is_orientable-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.is_orientable","text":"is_orientable(D::DeltaComplex)\n\nCkeck if the surface on which D lies is orientable or not.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.demigenus","page":"DeltaComplexes","title":"FlipGraphs.demigenus","text":"demigenus(D::DeltaComplex)\n\nCompute the demigenus of the DeltaComplex D.\n The demigenus or non-orientable genus (k) of a connected non-orientable closed surface is defined via the euler characteristic ()X) :\nk = 2 - X\n\n\n\n\n\n","category":"function"},{"location":"deltaComplex/#FlipGraphs.twist_edges!","page":"DeltaComplexes","title":"FlipGraphs.twist_edges!","text":"twist_edges!(D::DeltaComplex, t::Integer)\ntwist_edges!(T::TriFace)\n\nTwist or untwist all 3 edges in a TriFace, and reverse the side order.\n\nThis action gives an equivalent representation ot the same triangulation. It is usefull in the case that you would like to untwist a certain edge.\n\nExamples\n\njulia> D = delta_complex([1,2,-1,2]);\njulia> T = get_vertex(D,1);\njulia> edges(T)\n3-element Array{DualEdge,1}:\n DualEdge 2 : (Δ1)-(1)-------(2)-(Δ2)\n DualEdge 1 : (Δ1)-(2)-------(3)-(Δ2)\n DualEdge 3 : (Δ2)-(1)---↺---(3)-(Δ1)\n julia> twist_edges!(T);\n julia> edges(T)\n 3-element Array{DualEdge,1}:\n DualEdge 3 : (Δ2)-(1)-------(1)-(Δ1)\n DualEdge 1 : (Δ1)-(2)---↺---(3)-(Δ2)\n DualEdge 2 : (Δ1)-(3)---↺---(2)-(Δ2)\n\n\n\n\n\n","category":"function"},{"location":"deltaComplex/#Flipping","page":"DeltaComplexes","title":"Flipping","text":"","category":"section"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"A flip is defined as the action of replacing an edge in the triangulation by the other diagonal of the quadrilateral formed by the two triangles adjacent to the edge.","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"It has been shown, that the flipgraph of any closed surface is connected, hence it is possible, to obtain any triangulation by a finite number of flips.","category":"page"},{"location":"deltaComplex/","page":"DeltaComplexes","title":"DeltaComplexes","text":"    flip!(::DeltaComplex, ::Integer)\n    flip!(::DeltaComplex, ::DualEdge; ::Bool)\n    is_flippable(::DeltaComplex, ::Integer)\n    is_flippable(::DualEdge)\n    random_flips!(::DeltaComplex, ::Integer)\n    randomize!(::DeltaComplex; ::Integer, ::Integer, ::Integer, ::Integer)","category":"page"},{"location":"deltaComplex/#FlipGraphs.flip!-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"FlipGraphs.flip!","text":"flip!(D::DeltaComplex, e::Integer)\n\nFlip, if possible, the given edge in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.flip!-Tuple{DeltaComplex, DualEdge}","page":"DeltaComplexes","title":"FlipGraphs.flip!","text":"flip!(D::DeltaComplex, d::DualEdge)\n\nFlip, if possible, the given edge in D.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.is_flippable-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"FlipGraphs.is_flippable","text":"is_flippable(D::DeltaComplex, e::Integer)\n\nReturn true if the given edge can be flipped.\n\nThis is always the case if the edge does not connect a TriFace to itself.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.is_flippable-Tuple{DualEdge}","page":"DeltaComplexes","title":"FlipGraphs.is_flippable","text":"is_flippable(d::DualEdge)\n\nReturn true if the given edge is can be flipped.\n\nThis is always the case if the edge does not connect a TriFace to itself.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.random_flips!-Tuple{DeltaComplex, Integer}","page":"DeltaComplexes","title":"FlipGraphs.random_flips!","text":"random_flips!(D::DeltaComplex, n::Integer)\n\nRandomly pick an edge, and flip it if possible. Repeat this n times.\n\n\n\n\n\n","category":"method"},{"location":"deltaComplex/#FlipGraphs.randomize!-Tuple{DeltaComplex}","page":"DeltaComplexes","title":"FlipGraphs.randomize!","text":"randomize!(D::DeltaComplex; kwargs...) -> Int\n\nRandomly flip edges in D until D is sufficiently generic.\n\nReturn the number of attempted flips.\n\nThe measure by which we determin if D is sufficiently generic is through its diameter. This Method repeatedly flips a certain number of times. After each flip sequence the diameter is computed. Once this was repeated a certain number of times, the variance of all these past diameter measurements gets computed.\n\nIn theory, the variance should diminish over time. However, as we are flipping randomly, it will never truly converge to 0. A certain flutter in the variance is expected, this will at some point cause the variance to increase every so often. The algorithm stops once the last measured variance is bigger than the past few measurements.\n\nArguments\n\nnum_initial_flips::Integer=1000000 : the number of flips to do before even start taking measurements.\nnum_flips_per_step::Integer=10000 : the number of flips to do before computing the diameter each step.\nvariance_interval_size::Integer=10 : the number of diameters to store, before computing their variance. \nlookback_size::Integer=2 : how far back to compare the current variance to, in order to decide when to stop. \n\nExamples\n\njulia> D = delta_complex(30,30);\njulia> randomize!(D, num_initial_flips=10000, num_flips_per_step = 1000, variance_interval_size=10, lookback_size = 5)\n160000\n\n\n\n\n\n","category":"method"},{"location":"flipGraph_planar/#Flip-Graphs-of-Convex-Polygons","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"","category":"section"},{"location":"flipGraph_planar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"Flip Graphs, are obtained, by considering triangulations on a fixed set of points as vertices, and connect two vertices,  if it is possible to get from one triangulation to the other by flipping a single edge.","category":"page"},{"location":"flipGraph_planar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"    FlipGraphPlanar","category":"page"},{"location":"flipGraph_planar/#FlipGraphs.FlipGraphPlanar","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.FlipGraphPlanar","text":"struct FlipGraphPlanar <: AbstractGraph{Int32}\n\nA Graph representing the FlipGraph of a convex polygon. \n\nVertices are different triangulations of the same convex polygon.\n\nTwo vertices are linked by an edge, if the respective graphs differ only by a single flip.\n\n\n\n\n\n","category":"type"},{"location":"flipGraph_planar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"FlipGraphPlanar implements the AbstractGraph interface from Graphs.jl. It is therefore possible to use it with other packages that work with Graphs.jl. This is very helpfull for plotting the graph.","category":"page"},{"location":"flipGraph_planar/#Constructors","page":"Flip Graphs of Convex Polygons","title":"Constructors","text":"","category":"section"},{"location":"flipGraph_planar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"    flipgraph(::TriangulatedPolygon)\n    flipgraph_planar","category":"page"},{"location":"flipGraph_planar/#FlipGraphs.flipgraph-Tuple{TriangulatedPolygon}","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.flipgraph","text":"flipgraph(g::TriangulatedPolygon , modular=false)\n\nConstruct the FlipGraph for the TriangulatedPolygon g.\n\nIf modular is true, then vertices of the FlipGraph are the classes of isomorphisms up to renaming the vertices.  Each class is represented by one of its elements.\nIf modular is false, then each vertex is a different triangulation of the initial graph g.\nBy default, modular is set to false.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph_planar/#FlipGraphs.flipgraph_planar","page":"Flip Graphs of Convex Polygons","title":"FlipGraphs.flipgraph_planar","text":"flipgraph_planar(n::Integer, modular=false)\n\nConstruct the FlipGraph of a convex n-gon. \n\nIf modular=true, the FlipGraph is reduced to its modular form.\n\nExamples\n\njulia> flipgraph_planar(6, false)\nFlipGraphPlanar with 14 vertices and 21 edges\n\n\n\n\n\n","category":"function"},{"location":"flipGraph_planar/#Graph-methods","page":"Flip Graphs of Convex Polygons","title":"Graph methods","text":"","category":"section"},{"location":"flipGraph_planar/","page":"Flip Graphs of Convex Polygons","title":"Flip Graphs of Convex Polygons","text":"    nv(::FlipGraphPlanar)\n    ne(::FlipGraphPlanar)\n    vertices(::FlipGraphPlanar)\n    edges(::FlipGraphPlanar)\n    has_vertex(::FlipGraphPlanar,v)\n    has_edge(::FlipGraphPlanar,s,d)\n    has_edge(::FlipGraphPlanar,::Edge)\n    neighbors(::FlipGraphPlanar, ::Integer)\n    diameter(::FlipGraphPlanar)","category":"page"},{"location":"flipGraph_planar/#Graphs.nv-Tuple{FlipGraphPlanar}","page":"Flip Graphs of Convex Polygons","title":"Graphs.nv","text":"nv(G::FlipGraphPlanar)\n\nReturn the number of vertices in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph_planar/#Graphs.ne-Tuple{FlipGraphPlanar}","page":"Flip Graphs of Convex Polygons","title":"Graphs.ne","text":"ne(G::FlipGraphPlanar)\n\nReturn the number of edges in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph_planar/#Graphs.vertices-Tuple{FlipGraphPlanar}","page":"Flip Graphs of Convex Polygons","title":"Graphs.vertices","text":"vertices(G::FlipGraphPlanar)\n\nReturn the List of all vertices in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph_planar/#Graphs.edges-Tuple{FlipGraphPlanar}","page":"Flip Graphs of Convex Polygons","title":"Graphs.edges","text":"edges(G::FlipGraphPlanar) ::Vector{Edge}\n\nConstruct an array containing all the edges in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph_planar/#Graphs.has_vertex-Tuple{FlipGraphPlanar, Any}","page":"Flip Graphs of Convex Polygons","title":"Graphs.has_vertex","text":"has_vertex(G::FlipGraphPlanar, v)\n\nReturn true if v is a valid index of a vertex in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph_planar/#Graphs.has_edge-Tuple{FlipGraphPlanar, Any, Any}","page":"Flip Graphs of Convex Polygons","title":"Graphs.has_edge","text":"has_edge(G::FlipGraphPlanar, s, d)\n\nReturn true if there is an edge between s and d in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph_planar/#Graphs.has_edge-Tuple{FlipGraphPlanar, Graphs.SimpleGraphs.SimpleEdge}","page":"Flip Graphs of Convex Polygons","title":"Graphs.has_edge","text":"has_edge(G::FlipGraphPlanar, e::Edge)\n\nReturn true if e is an edge in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph_planar/#Graphs.neighbors-Tuple{FlipGraphPlanar, Integer}","page":"Flip Graphs of Convex Polygons","title":"Graphs.neighbors","text":"neighbors(G::FlipGraphPlanar, v::Integer) -> Vector{Int32}\n\nReturn a list of all the indices of vertices in G, that are adjacent to v.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph_planar/#Graphs.diameter-Tuple{FlipGraphPlanar}","page":"Flip Graphs of Convex Polygons","title":"Graphs.diameter","text":"diameter(G::FlipGraphPlanar)\n\nCompute the diameter of G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#FlipGraph","page":"FlipGraph","title":"FlipGraph","text":"","category":"section"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"Contrary to flipgraphs of planar triangulations like that of a convex polygon, the flipgraph of a closed surface is generally infinitely large. Therefore, it is impossible to construct the whole flipgraph. However, one can construct a local image of the flipgraph.","category":"page"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"    FlipGraph\n    nv(::FlipGraph)\n    ne(::FlipGraph)\n    vertices(::FlipGraph)\n    edges(::FlipGraph)\n    has_vertex(::FlipGraph, ::Integer)\n    has_edge(::FlipGraph,::Edge)\n    has_edge(::FlipGraph,::Integer, ::Integer)\n    has_edge(::FlipGraph,::HoleyDeltaComplex, ::HoleyDeltaComplex)\n    neighbors(::FlipGraph, ::Integer)\n    diameter(::FlipGraph)","category":"page"},{"location":"flipGraph/#FlipGraphs.FlipGraph","page":"FlipGraph","title":"FlipGraphs.FlipGraph","text":"struct FlipGraph <: AbstractGraph{Int}\n\nA Graph representing the flipgraph of a Δ-Complex.\n\nVertices are different triangulations of the same surface.\nTwo vertices are linked by an edge, if the respective graphs differ only by a single flip.\n\n\n\n\n\n","category":"type"},{"location":"flipGraph/#Graphs.nv-Tuple{FlipGraph}","page":"FlipGraph","title":"Graphs.nv","text":"nv(G::FlipGraph) -> Int\n\nReturn the number of vertices in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.ne-Tuple{FlipGraph}","page":"FlipGraph","title":"Graphs.ne","text":"ne(G::FlipGraph) -> Int\n\nReturn the number of edges in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.vertices-Tuple{FlipGraph}","page":"FlipGraph","title":"Graphs.vertices","text":"vertices(G::FlipGraph) -> Vector{HoleyDeltaComplex}\n\nReturn a list of all the vertices that have been constructed in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.edges-Tuple{FlipGraph}","page":"FlipGraph","title":"Graphs.edges","text":"edges(G::FlipGraph) ::Vector{Edge}\n\nConstruct an array containing all the edges in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.has_vertex-Tuple{FlipGraph, Integer}","page":"FlipGraph","title":"Graphs.has_vertex","text":"has_vertex(G::FlipGraph, v::Integer) -> Bool\n\nReturn true if v is a valid index of a vertex in G.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.has_edge-Tuple{FlipGraph, Graphs.SimpleGraphs.SimpleEdge}","page":"FlipGraph","title":"Graphs.has_edge","text":"has_edge(G::FlipGraph, e::Edge) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.has_edge-Tuple{FlipGraph, Integer, Integer}","page":"FlipGraph","title":"Graphs.has_edge","text":"has_edge(G::FlipGraph, s::Integer, d::Integer) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.has_edge-Tuple{FlipGraph, HoleyDeltaComplex, HoleyDeltaComplex}","page":"FlipGraph","title":"Graphs.has_edge","text":"has_edge(G::FlipGraph, HD1::HoleyDeltaComplex, HD2::HoleyDeltaComplex) -> Bool\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.neighbors-Tuple{FlipGraph, Integer}","page":"FlipGraph","title":"Graphs.neighbors","text":"neighbors(G::FlipGraph, v::Integer) -> Vector{Int}\n\nReturn a list of the indices of all the neighboring vertices of the v-th vertex.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Graphs.diameter-Tuple{FlipGraph}","page":"FlipGraph","title":"Graphs.diameter","text":"diameter(G::FlipGraph)\n\nReturn the diameter of the portion of the flipgraph that has been constructed.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Comparing-Triangulations","page":"FlipGraph","title":"Comparing Triangulations","text":"","category":"section"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"In order to decide whether two triangulations of a surface are in fact homeomorphic to each other and therefore equivalent, we need to use HoleyDeltaComplex's. One problem of deciding, if two triangulations are equivalent, is that the naming of the vertices, edges and points is completely arbitrary. Unless we are interested in the modular flipgraph, we can assume that the points are identical in two different instances of HoleyDeltaComplex.  However, in the act of flipping, DualEdges and TriFaces \"move around\". It is therefore possible, to obtain two HoleyDeltaComplexs representing the same triangulation of a surface but with different labeled TriFaces and DualEdges.  Checking every possible permutation of TriFace and DualEdge labelings is not an option, as the number of possibilities would blow up immeadiately. ","category":"page"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"What we do instead, is trying to find a canonical labeling. This Module uses a version of McKay's canonical graph labeling algorithm[1] to try and determin a unique labeling based on the relationship to other vertices and edges. In general, it is not always possible to determin a unique labeling.However, with this method, we can reduce the number of labelings to a manageable number.","category":"page"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"The mcKay Methods each return a permutation vector p which can be interpreted as Cauchy's one-line notation for permutations.  For example p = [3,5,1,2,6,4] would correspond to the following permutation:","category":"page"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"centering\nσ = beginpmatrix\n1  2  3  4  5  6\n3  5  1  2  6  4\nendpmatrix = (1 3)(2 5 6 4)","category":"page"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"    mcKay_points(::HoleyDeltaComplex; ::Bool)\n    mcKay_vertices(::HoleyDeltaComplex; ::Bool)\n    mcKay_edges(::HoleyDeltaComplex; ::Bool)\n\n    is_isomorph(::HoleyDeltaComplex, ::HoleyDeltaComplex)\n    is_isomorph_to(::HoleyDeltaComplex, ::HoleyDeltaComplex)","category":"page"},{"location":"flipGraph/#FlipGraphs.mcKay_points-Tuple{HoleyDeltaComplex}","page":"FlipGraph","title":"FlipGraphs.mcKay_points","text":"mcKay_points(HD::HoleyDeltaComplex; only_one::Bool=false)::Vector{Vector{Int}}\n\nApply a version of McKay's canonical graph labeling algorithm in order to determine all possible permutations  of the points which give a canonical isomorphism class representant.\n\nReturn a vector of permutation vectors p such that Point 1 becomes Point p[1], Point 2 becomes Point p[2],... If only_one=true, the algorithm stops after finding one valid permutation.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#FlipGraphs.mcKay_vertices-Tuple{HoleyDeltaComplex}","page":"FlipGraph","title":"FlipGraphs.mcKay_vertices","text":"mcKay_vertices(HD::HoleyDeltaComplex)::Vector{Vector{Int}}\n\nApply a version of McKay's canonical graph labeling algorithm in order to determine all possible permutations  of the triFaces which give a canonical isomorphism class representant.\n\nReturn a vector of permutation vectors p such that TriFace 1 becomes TriFace p[1], TriFace 2 becomes TriFace p[2],...\nIf only_one=true, the algorithm stops after finding one valid permutation.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#FlipGraphs.mcKay_edges-Tuple{HoleyDeltaComplex}","page":"FlipGraph","title":"FlipGraphs.mcKay_edges","text":"mcKay_edges(HD::HoleyDeltaComplex; only_one::Bool=false)::Vector{Vector{Int}}\n\nApply McKay's canonical graph labeling algorithm in order to determine all possible permutations  of the triFaces which give a canonical isomorphism class representant.\n\nReturn a vector of permutation vectors p such that DualEdge 1 becomes DualEdge p[1], DualEdge 2 becomes DualEdge p[2],...\nIf only_one=true, the algorithm stops after finding one valid permutation.\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#FlipGraphs.is_isomorph-Tuple{HoleyDeltaComplex, HoleyDeltaComplex}","page":"FlipGraph","title":"FlipGraphs.is_isomorph","text":"is_isomorph(HD1::HoleyDeltaComplex, HD2::HoleyDeltaComplex; kwargs) -> Bool\n\nReturn true if HD1 is isomorph to HD2 up to a renaming of the vertices, edges and if modular=true also points.\n\nArguments\n\nmodular::Bool=false : If modular is set to true, then the isomorphism also includes a renaming of the points. \n\nSee also is_isomorph_to\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#FlipGraphs.is_isomorph_to-Tuple{HoleyDeltaComplex, HoleyDeltaComplex}","page":"FlipGraph","title":"FlipGraphs.is_isomorph_to","text":"is_isomorph_to(HD::HoleyDeltaComplex, HD2::HoleyDeltaComplex; kwargs...) -> Bool\n\nReturn true if HD is identical to HD2 up to a renaming of the points (if modular=true), edges and triFaces.\n\nHD is supposed to be already renamed in a canonical way. \n\nArguments\n\nmodular::Bool=false : If modular is set to true, then the isomorphism also includes a renaming of the points. \n\nSee also is_isomorph\n\n\n\n\n\n","category":"method"},{"location":"flipGraph/#Constructing-the-FlipGraph","page":"FlipGraph","title":"Constructing the FlipGraph","text":"","category":"section"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"Contrary to flipgraphs of planar triangulations like that of a convex polygon, the flipgraph of a closed surface is generally infinitely large. Therefore, it is impossible to construct the whole flipgraph. However, one can construct a local image of the flipgraph.","category":"page"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"    flip_graph(::HoleyDeltaComplex, ::Integer; ::Bool)","category":"page"},{"location":"flipGraph/#FlipGraphs.flip_graph-Tuple{HoleyDeltaComplex, Integer}","page":"FlipGraph","title":"FlipGraphs.flip_graph","text":"flip_graph(HD::HoleyDeltaComplex, depth::Integer; kwargs)\n\nConstruct the FlipGraph for the HoleyDeltaComplex HD.  \n\nIf modular is true, then vertices of the FlipGraph are the classes of isomorphisms up to renaming the vertices. Each class is represented by one of its elements.\nIf modular is false, then each vertex is a different triangulation of the initial graph g.\nBy default, modular is set to true.\n\nArguments\n\nmodular::Bool=false : If modular is set to true, then the isomorphism also includes a renaming of the points. \n\n\n\n\n\n","category":"method"},{"location":"flipGraph/","page":"FlipGraph","title":"FlipGraph","text":"[1]: Hartke, S.G., & Radcliffe, A.J. (2008). McKay ’ s Canonical Graph Labeling Algorithm.","category":"page"},{"location":"generalUtilities/#General-utilities","page":"General Utilities","title":"General utilities","text":"","category":"section"},{"location":"generalUtilities/","page":"General Utilities","title":"General Utilities","text":"These are some helping methods which youmight want to use, but aren't specific to one of the main structures in this package.","category":"page"},{"location":"generalUtilities/","page":"General Utilities","title":"General Utilities","text":"\ndiameter(::Matrix{<:Integer})\nadjacency_matrix(::Vector{Vector{T}}) where T<:Integer\ninvert_permutation(::Vector{<:Integer})\ndegrees(A::Matrix{<:Integer})","category":"page"},{"location":"generalUtilities/#Graphs.diameter-Tuple{Matrix{var\"#s2\"} where var\"#s2\"<:Integer}","page":"General Utilities","title":"Graphs.diameter","text":"diameter(adjacency_matrix :: Matrix{<:Integer}) :: Int\n\nCompute the diameter of a graph from its simple adjacency matrix.\n\nAll values in adjacency_matrix should be either 0 or 1.\n\n\n\n\n\n","category":"method"},{"location":"generalUtilities/#FlipGraphs.adjacency_matrix-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T<:Integer","page":"General Utilities","title":"FlipGraphs.adjacency_matrix","text":"adjacency_matrix(adjList::Vector{Vector{<:Integer}}) -> Matrix{Int}\n\nConstruct the adjacency matrix from an adjaceny list.\n\n\n\n\n\n","category":"method"},{"location":"generalUtilities/#FlipGraphs.invert_permutation-Tuple{Vector{var\"#s2\"} where var\"#s2\"<:Integer}","page":"General Utilities","title":"FlipGraphs.invert_permutation","text":"invert_permutation(p::Vector{<:Integer})\n\nReturn the inverse of the permutation p. \n\nExample\n\njulia> p = [2,1,4,5,3];\njulia> p_inv = invert_perm(p); \njulia> show(p_inv)\n[4, 2, 5, 1, 6, 3]\njulia> show(p_inv[p])\n[1, 2, 3, 4, 5, 6]\n\n\n\n\n\n","category":"method"},{"location":"generalUtilities/#FlipGraphs.degrees-Tuple{Matrix{var\"#s2\"} where var\"#s2\"<:Integer}","page":"General Utilities","title":"FlipGraphs.degrees","text":"degrees(A::Matrix{<:Integer}) -> Vector{<:Integer}\n\nReturn a vector containing the degrees of every vertex given an adjacency matrix A.\n\n\n\n\n\n","category":"method"},{"location":"#FlipGraphs.jl-Documentation","page":"About","title":"FlipGraphs.jl Documentation","text":"","category":"section"},{"location":"","page":"About","title":"About","text":"Welcome to the documentation of the FlipGraphs package.  This package is part of my master's thesis on triangulations of closed surfaces.","category":"page"},{"location":"","page":"About","title":"About","text":"The aim of the package, is to model triangulations on any closed surface and to compute their respective flipgraphs.","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"To install the package, you first need to install Julia.  After starting Julia, type the following:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using Pkg \njulia> Pkg.add(url=\"https://github.com/schto223/FlipGraphs.jl\")","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"You can start using the package as follows:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using FlipGraphs\njulia> createDeltaComplex(4,10)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"You can get help for a function or structure by putting a question mark in front.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"help?> FlipGraph\n  struct FlipGraph <: AbstractGraph{Int}\n\n  A Graph representing the flipgraph of a Δ-Complex.\n\n  Vertices are different triangulations of the same surface.\n  Two vertices are linked by an edge, if the respective graphs differ only by a single flip.","category":"page"},{"location":"quickStart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"If you're already familiar with the concept of flipgraphs, triangulations on closed surfaces and Δ-complexes, and don't to read the whole documentation of what what is, then here are some quick examples of what you can do with this package.","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"In any other case, please be sure to have a look at the rest of the documentation first.","category":"page"},{"location":"quickStart/#Triangulated-Convex-Polygon","page":"Quick Start","title":"Triangulated Convex Polygon","text":"","category":"section"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Create a triangulated convex 10-gon:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> g = triangulated_polygon(10)\nTriangulatedPolygon with 10 vertices, and adjacency list:\n[[2, 10], [1, 3, 10], [2, 4, 10, 9], [3, 5, 9, 8], [4, 6, 8, 7], [5, 7], [6, 8, 5], [7, 9, 4, 5], [8, 10, 3, 4], [9, 1, 2, 3]]","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Check if the edge going from vertex 2 to vertex 10 can be flipped:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> is_flippable(g, 2, 10)\ntrue","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Flip said edge:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> flip!(g, 2, 10)\nTriangulatedPolygon with 10 vertices, and adjacency list:\n[[2, 10, 3], [1, 3], [2, 4, 10, 9, 1], [3, 5, 9, 8], [4, 6, 8, 7], [5, 7], [6, 8, 5], [7, 9, 4, 5], [8, 10, 3, 4], [9, 1, 3]]","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Construct the flipgraph of an Octagon:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> G = flipgraph_planar(8)\nFlipGraphPlanar with 132 vertices and 330 edges","category":"page"},{"location":"quickStart/#Δ-Complex-/-Triangulation-of-closed-surface","page":"Quick Start","title":"Δ-Complex / Triangulation of closed surface","text":"","category":"section"},{"location":"quickStart/#DeltaComplex","page":"Quick Start","title":"DeltaComplex","text":"","category":"section"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"A DeltaComplex is a simplified triangulation on a closed surface. (Can be used to compute things like the diameter etc. But does not offer a unique modelisation of a triangulation on a closed surface)","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Create a DeltaComplex of a surface of genus 1 with 2 points ","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> D = delta_complex(1, 2)\nDeltaComplex on orientable surface of genus 1 with 2 points\n4 TriFaces:\n TriFace #1: Points(1 1 2) Neighbors(2 3 4)\n TriFace #2: Points(1 1 1) Neighbors(4 1 3)\n TriFace #3: Points(1 1 2) Neighbors(2 4 1)\n TriFace #4: Points(1 1 2) Neighbors(2 1 3)\n6 DualEdges:\n DualEdge 1 : (Δ3)-(1)-------(3)-(Δ2)\n DualEdge 2 : (Δ1)-(1)-------(2)-(Δ2)\n DualEdge 3 : (Δ2)-(1)-------(1)-(Δ4)\n DualEdge 4 : (Δ4)-(2)-------(3)-(Δ1)\n DualEdge 5 : (Δ1)-(2)-------(3)-(Δ3)\n DualEdge 6 : (Δ3)-(2)-------(3)-(Δ4)","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Check if the 4th edge (DualEdge 4) can be flipped:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> is_flippable(D, 4)\ntrue","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Flip said edge:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> flip!(D, 4)\nDeltaComplex on orientable surface of genus 1 with 2 points\n4 TriFaces:\n TriFace #1: Points(1 2 1) Neighbors(3 3 4)\n TriFace #2: Points(1 1 1) Neighbors(4 4 3)\n TriFace #3: Points(1 1 2) Neighbors(2 1 1)\n TriFace #4: Points(1 1 1) Neighbors(2 1 2)\n6 DualEdges:\n DualEdge 1 : (Δ3)-(1)-------(3)-(Δ2)\n DualEdge 2 : (Δ4)-(1)-------(2)-(Δ2)\n DualEdge 3 : (Δ2)-(1)-------(3)-(Δ4)\n DualEdge 4 : (Δ4)-(2)-------(3)-(Δ1)\n DualEdge 5 : (Δ1)-(1)-------(3)-(Δ3)\n DualEdge 6 : (Δ3)-(2)-------(2)-(Δ1)","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Randomly flip edges in D until it the diameter stabilizes:","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> randomize!(D)\n10300000\njulia> D\nDeltaComplex on orientable surface of genus 1 with 2 points\n4 TriFaces:\n TriFace #1: Points(1 1 1) Neighbors(3 2 2)\n TriFace #2: Points(1 1 1) Neighbors(1 3 1)\n TriFace #3: Points(1 1 1) Neighbors(1 2 4)\n TriFace #4: Points(2 1 1) Neighbors(4 3 4)\n6 DualEdges:\n DualEdge 1 : (Δ3)-(3)-------(2)-(Δ4)\n DualEdge 2 : (Δ3)-(2)-------(2)-(Δ2)\n DualEdge 3 : (Δ4)-(3)-------(1)-(Δ4)\n DualEdge 4 : (Δ1)-(2)-------(3)-(Δ2)\n DualEdge 5 : (Δ1)-(1)-------(1)-(Δ3)\n DualEdge 6 : (Δ2)-(1)-------(3)-(Δ1)","category":"page"},{"location":"quickStart/#HoleyDeltaComplex","page":"Quick Start","title":"HoleyDeltaComplex","text":"","category":"section"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"A DeltaComplex is a more elaborate modelisation of a triangulation on a closed surface. This allows to determine if two triangulisations are homeomorph to each other or not. This comes however at the cost of efficiency.","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> HD = holey_delta_complex(1, 2)\nHoleyDeltaComplex on orientable surface of genus 1 with: 2 Points; 4 TriFaces; \n6 DualEdges; 1 Hole:\nHole 1 : --<--3⤈-1⤈-6⤉--<--","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"Construct a local image of the flipgraph containing HD up to a depth of 5.","category":"page"},{"location":"quickStart/","page":"Quick Start","title":"Quick Start","text":"julia> flip_graph(HD, 5)\nFlipGraph with 98 vertices and 154 edges","category":"page"}]
}
